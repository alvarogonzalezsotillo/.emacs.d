#+TITLE: Configuración /Emacs/ de Álvaro González
#+OPTIONS: toc:4 h:4

* Opciones /latex/ :noexport:
# COLORES
#+latex_header: \usepackage[usenames,dvipsnames]{color} % Required for custom colors

# LISTADOS LATEX
#+latex_header: \renewcommand{\ttdefault}{pcr} % MONOESPACIO CON NEGRITA
#+latex_header: \usepackage{listings}
#+latex_header: \usepackage{listingsutf8}
#+latex_header: \usepackage{indentfirst}
#+latex_header: \lstset{frame=single,inputencoding=utf8,basicstyle=\scriptsize\ttfamily,showstringspaces=false,numbers=none}
#+latex_header: \definecolor{MyDarkGreen}{rgb}{0.0,0.4,0.0} % This is the color used for comments
#+latex_header: \lstset{ breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}, keywordstyle=\bfseries, keywordstyle=[1]\color{Blue}\bfseries,  keywordstyle=[2]\color{Purple}\bfseries,  keywordstyle=[3]\color{Blue}\underbar,   identifierstyle=,   commentstyle=\color{MyDarkGreen},   stringstyle=\color{Purple},   showstringspaces=false,   tabsize=2,   morecomment=[l][\color{Blue}]{...} }
#+latex_header: \lstset{literate=  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1   {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1   {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1   {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1   {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1   {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1   {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1   {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1   {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1   {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1   {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1   {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1   {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1 } 

# OPCIONES DE PÁGINA DE LATEX
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS:
#+LATEX_HEADER: \usepackage[margin=2.5cm,includeheadfoot,includehead,includefoot]{geometry} 
#+LATEX_HEADER: \hypersetup{colorlinks,linkcolor=black}

# CABECERA Y PIE LATEX
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \pagestyle{fancyplain}
#+LATEX_HEADER: \chead{}
#+LATEX_HEADER: \lhead{}
#+LATEX_HEADER: \rhead{}
#+LATEX_HEADER: \cfoot{}
#+LATEX_HEADER: \lfoot{alvarogonzalezsotillo@gmail.com}
#+LATEX_HEADER: \rfoot{\thepage}

#+latex: \begin{center}
La última versión de esta configuración puede encontrarse en [[https://github.com/alvarogonzalezsotillo/.emacs.d][https://github.com/alvarogonzalezsotillo/.emacs.d]].
#+latex: \end{center}

* Cómo funciona este fichero

La configuración de Emacs se realiza con código elisp. Al contrario que otros editores, que están pensados para ser usados sin demasiada customización, los usuarios de Emacs solemos cambiarlo de forma bastante /extrema/ (¡por eso nos gusta!).

El problema es que, como con cualquier otro programa que se va modificando durante años, acabas olvidando el por qué de ciertas líneas de código, o dónde se realiza alguna coniguración. Para evitar remediarlo, se puede utilizar org-mode para crear al mismo tiempo la documentación y el código de la configuración (como en literate programming). Descubrí en el blog de  [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua]] que podía mantener la configuración en un fichero =orgmode= y así documentar fácilmente cada opción.

Cada bloque de código de tipo =emacs-lisp= se ejecuta al inicio. Algunos bloques está deshabilitados, marcándolos con el tipo =lisp=. Así mantienen su apariencia, pero no son interpretados.

** =init.el=
Emacs comienza cargando el fichero =~/.emacs.d/init.el=. Este fichero simplemente inicializa el sistema de paquetes y carga el paquete =org=, que es el que permite a Emacs manejar este tipo de ficheros. Después, carga este fichero interpretando los bloques de código.

#+begin_src lisp 
(package-initialize nil)
(setq package-check-signature nil)
(setq package-archives '(
      ("org" . "http://orgmode.org/elpa/")
      ("melpa" . "http://melpa.org/packages/")))


(package-initialize t)
(package-refresh-contents) ; OPCIONAL, NECESITA CONEXIÓN A INTERNET
(package-install 'org)
(require 'org)
(require 'ob-tangle)
(org-babel-load-file (expand-file-name "~/.emacs.d/config.org"))
#+end_src

** Algunos problemas
- A veces, se empieza usando una versión de =org= (de gnu), y después se  utiliza la del repositorio de orgmode, lo que puede dar problemas. En ese caso, se necesitan dos reinicios.
- Los ficheros =org= dan problemas sin tienen un =title:= definido y la versión de =org= instalada no se recompiló. Para solucionarlo:
  #+begin_src sh
  rm $(find ~/.emacs.d/elpa | grep .elc$)
  #+end_src
- En instalaciones nuevas, la carga final de =custom.el= falla si no existe.


* Utilidades externas al /PATH/
En el directorio =~/.emacs.d/bin/= guardo algunas utilidades que me interesa tener en todos los entornos de trabajo. Lo siguiente es para que estén disponibles desde las /shells/ que arranque desde emacs
#+begin_src emacs-lisp
(setenv "PATH" (concat (expand-file-name "~/.emacs.d/bin") ":" (getenv "PATH")))
(setq exec-path (append exec-path '("~/.emacs.d/bin")))
#+end_src

Las utilidades pueden consultarse en el [[https://github.com/alvarogonzalezsotillo/.emacs.d/tree/master/bin][repositorio en github]], y son:
#+begin_src shell :exports results
ls ~/.emacs.d/bin
#+end_src

#+RESULTS:
| addtopath.sh           |
| ec                     |
| ghpages.sh             |
| gifttolatex            |
| githubclone.sh         |
| keymon.sh              |
| plantuml.1.2018.11.jar |
| rmtemplatex.sh         |
| shrinkpdf.sh           |
| svg2pdf.sh             |
| vncserver.sh           |
| wake-alvarogonzalez.sh |


* Paquetes

Utilizo tres repositorios de paquetes:
- melpa: el más habitual
- gnu: me hizo falta para algo que no recuerdo, lo tengo actualmente deshabilitado.
- org: las versiones nuevas de org-mode se publican antes en este repositorio

Guardo los paquetes que necesito en una variable, y se reinstalan si no están ya instalados.


#+begin_src emacs-lisp
  (setq package-check-signature nil)

  (package-initialize)

  ;; LISTA DE PAQUETES UTILIZADOS
  (defvar my/install-packages
    '(
      2048-game
      adaptive-wrap
      ag
      alert
      auto-highlight-symbol
      bind-key
      bm
      calfw
      calfw-ical
      chess
      color-theme-sanityinc-tomorrow
      company
      company-auctex
      company-c-headers
      company-emoji
      company-flx
      company-lsp
      company-quickhelp
      company-restclient
      company-shell
      company-web
      crappy-jsp-mode
      default-text-scale
      diffview
      dired-narrow
      dumb-jump
      ensime
      expand-region
      flycheck
      gift-mode
      git-gutter
      git-timemachine
      gitignore-mode
      graphviz-dot-mode
      helm-ag
      helm-company
      helm-flx
      helm-gitignore
      helm-google
      helm-projectile
      highlight-indent-guides
      howdoi
      htmlize
      ibuffer-projectile
      ibuffer-sidebar
      image+
      imenu-anywhere
      imenu-list
      intellij-theme
      kodi-remote
      latex-preview-pane
      lorem-ipsum
      ;lsp-css
      lsp-mode
      lsp-javascript-typescript
      lsp-ui
      magit
      markdown-mode
      markdown-preview-mode
      multiple-cursors
      neotree
      ob-restclient
      org
      org-attach-screenshot
      org-page
      ox-reveal
      page-break-lines
      paradox
      php-mode
      plantuml-mode
      popup-imenu
      popup-complete
      popup-switcher
      popwin
      prettier-js
      quickrun
      rectangle-utils
      request-deferred
      restclient
      restclient-helm
      scad-mode
      scad-preview
      scala-mode
      skewer-mode
      smartparens
      smartscan
      sublimity
      swiper-helm
      switch-window
      swoop
      helm-swoop
      tablist
      transmission
      transpose-frame
      use-package
      vim-empty-lines-mode
      volatile-highlights
      web-beautify
      web-mode
      wgrep
      wgrep-helm
      which-key
      yafolding
      yasnippet
      yasnippet-snippets
      ))

  (defvar my/packages-refreshed? nil)

  (defun reinstalar-paquetes-en-emacs-nuevo()
    (interactive)
    (dolist (pack my/install-packages)
      (message (concat "Refrescando:" (symbol-name pack )))
      (unless (package-installed-p pack)
        (message (concat "Necesita reinstalar:" (symbol-name pack )))
        (unless my/packages-refreshed?
          (package-refresh-contents)
          (setq my/packages-refreshed? t))
        (package-install pack))))


  (defun requerir-paquetes ()
    "Requiere los paquetes para no tener variables indefinidas."
    (dolist (pack my/install-packages)
      (message (concat "Requires:" (symbol-name pack )))
      (require pack)))


  (reinstalar-paquetes-en-emacs-nuevo)
  (requerir-paquetes)


#+end_src

Por último, el paquete =ob-scala= es un paquete local bajado de [[https://github.com/tkf/org-mode/blob/master/lisp/ob-scala.el][https://github.com/tkf/org-mode/blob/master/lisp/ob-scala.el]]. Sirve para ejecutar código =scala= directamente desde un documento =orgmode=.

#+begin_src emacs-lisp
(require 'ob-scala)
#+end_src

** Parches sobre los paquetes
En este momento los paquetes ya están cargados, pero necesito modificar el comportamiento de algunos de ellos de formas que no están soportadas en su configuración

** =dumb-jump=
Añado las siguientes reglas para hacer búsquedas simples con =dumb-jump= en ficheros =sql= y =org=.
#+begin_src emacs-lisp
;; ADITIONAL DUMBJUMB RULES
(add-to-list 'dumb-jump-find-rules
  '(:type "something" :supports ("ag" "grep" "rg" "git-grep") :language "sql"
           :regex ": \\bJJJ\\j"))
(add-to-list 'dumb-jump-find-rules
  '(:type "something" :supports ("ag" "grep" "rg" "git-grep") :language "org"
           :regex ": \\bJJJ\\j"))
#+end_src

** =ox-reveal=
Cuando exporto un fichero =org= a =reveal.js= tengo problemas en la forma en que se escapan los caracteres =>= y =<= de los bloques de código. Con esta redefinición de la función =org-reveal-src-block= queda solucionado

#+begin_src emacs-lisp
;; ESCAPE HTML IN REVEAL
(setq mi-org-html-protect-char-alist
  '(("&" . "&amp;")
    ("<" . "&lt;")
    (">" . "&gt;")
    ("\\%" . "&#37;")))

(defun mi-org-html-encode-plain-text (text)
  "Convert plain text characters from TEXT to HTML equivalent.
Possible conversions are set in `org-html-protect-char-alist'."
  (dolist (pair org-html-protect-char-alist text)
    (setq text (replace-regexp-in-string (car pair) (cdr pair) text t t))))


(defun org-reveal-src-block (src-block contents info)
  "Transcode a SRC-BLOCK element from Org to Reveal.
CONTENTS holds the contents of the item.  INFO is a plist holding
contextual information."
  (if (org-export-read-attribute :attr_html src-block :textarea)
      (org-html--textarea-block src-block)
    (let* ((use-highlight (org-reveal--using-highlight.js info))
           (lang (org-element-property :language src-block))
           (caption (org-export-get-caption src-block))
           (not-escaped-code (if (not use-highlight)
                     (org-html-format-code src-block info)
                   (cl-letf (((symbol-function 'org-html-htmlize-region-for-paste)
                              #'buffer-substring))
                     (org-html-format-code src-block info))))
           (code (mi-org-html-encode-plain-text not-escaped-code))
           ;(code  not-escaped-code)
           
           (frag (org-export-read-attribute :attr_reveal src-block :frag))
	   (code-attribs (or (org-export-read-attribute
			 :attr_reveal src-block :code_attribs) ""))
           (label (let ((lbl (org-element-property :name src-block)))
                    (if (not lbl) ""
                      (format " id=\"%s\"" lbl)))))
      (if (not lang)
          (format "<pre %s%s>\n%s</pre>"
                  (or (frag-class frag info) " class=\"example\"")
                  label
                  code)
        (format
         "<div class=\"org-src-container\">\n%s%s\n</div>"
         (if (not caption) ""
           (format "<label class=\"org-src-name\">%s</label>"
                   (org-export-data caption info)))
         (if use-highlight
             (format "\n<pre%s%s><code class=\"%s\" %s>%s</code></pre>"
                     (or (frag-class frag info) "")
                     label lang code-attribs code)
           (format "\n<pre %s%s>%s</pre>"
                   (or (frag-class frag info)
                       (format " class=\"src src-%s\"" lang))
                   label code)))))))
#+end_src







* /Customize/
El fichero de /customize/ lo mantengo aparte del =init.el=, para separar entornos y mejor integración con el control de versiones.
#+begin_src emacs-lisp
(setq custom-file "~/.emacs.d/custom-file.el")
(load custom-file)
#+end_src

* Edición


** Tabuladores /vs/ espacios
No utilizo tabuladores en las indentaciones. 
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
(setq tab-width 2)
#+end_src

** Comportamiento de la selección
Al comenzar a escribir con una selección, se borra lo seleccionado. 
#+begin_src emacs-lisp
(delete-selection-mode 1)
#+end_src

Al copiar la  selección, mantener la selección 
#+begin_src emacs-lisp
(defadvice kill-ring-save (after keep-transient-mark-active ())
  "Override the deactivation of the mark."
  (setq deactivate-mark nil))
(ad-activate 'kill-ring-save)
#+end_src


** Línea nueva al final de fichero
Los ficheros deben tener una línea nueva al final. Además, indicar el fin de fichero como en =vim=.
#+begin_src emacs-lisp
(setq indicate-empty-lines t require-final-newline t)
#+end_src


** Historia del portapapeles
Una de las ventajas de Emacs es su /kill ring/, donde se guarda la historia del portapapeles. Con esta opción, añado a esta historia el portapapeles del sistema. Descubierto en [[https://writequit.org/org/settings.html#sec-1-33][https://writequit.org/org/settings.html#sec-1-33]]
#+begin_src emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+end_src

** Recarga de ficheros modificados
Encuentro más conveniente que los ficheros se recarguen si un programa externo los modifica, sin preguntas.

#+begin_src emacs-lisp
(global-auto-revert-mode 1)
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)
#+end_src

** Comandos que se consideran /avanzados/
Emacs tiene algunos compandos considerados confusos deshabilitados. Hay opciones útiles que prefiero que estén activadas por defecto.
#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)
#+end_src

** =yasnippet=
Plantillas para introducción rápida de partes del texto
#+begin_src emacs-lisp
(yas-global-mode 1)
#+end_src


** Paréntesis
Este modo cierra automáticamente los paréntesis y otros bloques
#+begin_src emacs-lisp
(smartparens-global-mode 1)
#+end_src

Con estos cambios, se tienen en cuenta los formatos de orgmode en electric-pair-mode
#+begin_src emacs-lisp
(require 'org)
(modify-syntax-entry ?~ "(~" org-mode-syntax-table)
(modify-syntax-entry ?= "(=" org-mode-syntax-table)
(modify-syntax-entry ?* "(*" org-mode-syntax-table)
(modify-syntax-entry ?/ "(/" org-mode-syntax-table)

#+end_src


** =company=
Utilizo =company= como mecanismo de autocomplección. Distingo entre modos de programación y =org-mode=.

#+begin_src emacs-lisp
  (require 'company)
  (company-flx-mode +1)



  (defvar my-company-backends-prog-mode
    '(
      (
       company-web-html
       company-files
       company-dabbrev-code
       company-capf
       company-keywords
       company-lsp
       company-yasnippet
       company-emoji
       company-capf
       )
      )
    )


  (defvar my-company-backends-org-mode
    '(
      (
       company-files
       company-dabbrev-code
       company-dabbrev
       company-keywords
       company-yasnippet
       company-emoji
       company-capf
       )
      )
    )

  (defvar my-company-backends my-company-backends-org-mode)

  ;; set default `company-backends'
  (setq company-backends my-company-backends)
  (company-auctex-init)

  (add-hook 'after-init-hook 'global-company-mode)

  (company-quickhelp-mode 1)

  (defun my-company-backends-org-mode-function ()
    (interactive)
    (set (make-local-variable 'company-backends) my-company-backends-org-mode))

  (add-hook 'org-mode-hook #'my-company-backends-org-mode-function)

  (defun my-company-backends-prog-mode-function ()
    (interactive)
    (set (make-local-variable 'company-backends) my-company-backends-prog-mode))


  (add-hook 'prog-mode-hook #'my-company-backends-prog-mode-function)


  (define-key company-active-map [escape] 'company-abort)
  (global-company-mode)

#+end_src

Prefiero que =dabbrev= funcione en comentarios y cadenas. Y que tenga en cuenta el /case/
#+begin_src emacs-lisp
  (setq company-dabbrev-code-everywhere t)
  (setq company-dabbrev-code-ignore-case nil)
  (setq company-dabbrev-everywhere t)
  (setq company-dabbrev-ignore-case 'keep-prefix)
  (setq company-dabbrev-downcase nil)
#+end_src

#+RESULTS:



* Navegación


Scroll con teclas de avance de página hasta el extremo del fichero. Sin esta opción, /Emacs/ no avanza hasta la primera línea si al dar a =RePag= no quedan páginas por retroceder.
#+begin_src emacs-lisp
(setq scroll-error-top-bottom t)
#+end_src



Utilizo =smartscan= para localizar ocurrencias de símbolos.
#+begin_src emacs-lisp
(global-smartscan-mode 1)
#+end_src

Algunas ventanas tienen menor /importancia/ que otras, ya que tienden a ser temporales (por ejemplo, las ventanas de ayuda). Con =popwin=, estas ventanas ocupan menos espacio en pantalla y desaparecen con =C-g=
#+begin_src emacs-lisp
(popwin-mode 1)
#+end_src


Agrupo los buffers por proyecto de =projectile=
#+begin_src emacs-lisp
(add-hook 'ibuffer-hook #'ibuffer-projectile-set-filter-groups)
(add-hook 'ibuffer-sidebar-mode-hook #'ibuffer-projectile-set-filter-groups)
#+end_src


Retroceder en la historia de disposición de ventanas y búferes
#+begin_src emacs-lisp
(winner-mode 1)
#+end_src


Grabar la disposición de bufers y ventanas para la siguiente sesión
#+begin_src emacs-lisp
(setq desktop-save t)
(desktop-save-mode)
#+end_src


** =projectile=
=projectile= necesita conocer su tecla de prefijo (utilizo la tradicional).
#+begin_src emacs-lisp
(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
(projectile-mode 1)
#+end_src




* Mi configuración

** =neotree=
En =neotree=, quiero ver todos los ficheros, y no me importa el ancho fijo de la ventana.
#+begin_src emacs-lisp

  ; https://github.com/jaypei/emacs-neotree/issues/149
  (defun neotree-project-root-dir-or-current-dir ()
    "Open NeoTree using the project root, using projectile, or the
  current buffer directory."
    (interactive)
    (let ((project-dir (ignore-errors (projectile-project-root)))
          (file-name (buffer-file-name))
          (neo-smart-open t))
      (if (neo-global--window-exists-p)
          (neotree-hide)
        (progn
          (neotree-show)
          (if project-dir
              ;(neotree-dir project-dir)
              (neotree-projectile-action))
          (if file-name
              (neotree-find file-name))))))

  (setq neo-show-hidden-files t)
  (setq neo-window-fixed-size nil)
  (setq neo-hidden-regexp-list (quote ("\\.pyc$" "~$" "^#.*#$" "\\.elc$")))

#+end_src

#+RESULTS:
| \.pyc$ | ~$ | ^#.*#$ | \.elc$ |


** Correo electrónico
Para enviar email utilizo =sendmail= (lo suelo tener configurado con un /smarthost/)
#+begin_src emacs-lisp
(setq send-mail-function (quote sendmail-send-it))
#+end_src

** =quickrun=
=Quickrun= ejecuta el buffer actual. Aumento el tiempo límite de la ejecución antes de matar el proceso.
#+begin_src emacs-lisp
(setq quickrun-timeout-seconds 100)
#+end_src


** =tramp=
=tramp= intenta optimizar las conexiones, enviando en línea los ficheros pequeños. Esto me da problemas en algunos sistemas, así que indico que los ficheros se copien a partir de 1 byte de tamaño:
#+begin_src emacs-lisp
(setq tramp-copy-size-limit 1)
(setq tramp-debug-buffer t)
(setq tramp-verbose 10)
#+end_src

En ocasiones, =tramp= no consigue conectar con un usuario que tiene =zsh= como shell. Para ello, hay que añadir lo siguiente al fichero =.zshrc= remoto:
#+begin_src sh
EN .zshrc PARA QUE FUNCIONE tramp
if [[ "$TERM" == "dumb" ]]
then
  unsetopt zle
  unsetopt prompt_cr
  unsetopt prompt_subst
  unfunction precmd
  unfunction preexec
  PS1='$ '
fi
#+end_src



** /Backup/ de ficheros
Emacs guarda una copia de seguridad de los ficheros editados. Si no se configura, crea la copia en el mismo directorio.

Las copias de seguridad son interesantes aunque se utilice un control de versiones. Por ejemplo, se guardan versiones de ficheros del sistema y de los editados con Tramp.

Prefiero guardar todas las copias en un directorio, manteniendo varias versiones de cada fichero.

Tampoco me interesan los ficheros de /lock/.
#+begin_src emacs-lisp
  (setq backup-directory-alist `(("." . "~/.saves")))
  (setq backup-by-copying t)
  (setq delete-old-versions t
        kept-new-versions 6
        kept-old-versions 2
        version-control t)

  (setq create-lockfiles nil)
#+end_src

** =doc-view=
Para visualizar documentos desde Emacs, aumento su resolución y anchura.
#+begin_src emacs-lisp
(require 'doc-view)
(setq doc-view-continuous t)
(setq doc-view-image-width 1600)
(setq doc-view-resolution 400)
#+end_src

** =org-mode=


*** Lenguajes =org-babel=
Habilito varios lenguajes que pueden ejecutarse directamente desde los bloques de =orgmode=.
#+begin_src emacs-lisp
  (setq org-plantuml-jar-path "/home/alvaro/apuntes-clase/bin/plantuml.1.2018.11.jar")
  (setq plantuml-jar-path org-plantuml-jar-path)

  (setq org-babel-load-languages '((scala . t) (shell . t) (emacs-lisp . t) (dot . t) (plantuml . t ) ( C . t)))

  (org-babel-do-load-languages 'org-babel-load-languages
                               '(
                                 (C . t )
                                 (dot . t)
                                 (plantuml . t)
                                 (scala . t)
                                 (shell . t)
                                 ))
#+end_src


 Además, no pido confirmación para varios lenguajes                                                                                                           
 #+begin_src emacs-lisp
 (defun my-org-confirm-babel-evaluate (lang body)                                                                                                             
   (not (member lang '("dot" "emacs-lisp" "shell"))))
 (setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)                                                                                             
#+end_src

   
*** Listas alfabéticas
#+begin_src emacs-lisp
(setq org-list-allow-alphabetical t)
#+end_src


*** Listados /Latex/
Utilizo el paquete =listings= de /Latex/ en vez de bloques /verbatim/.
#+begin_src emacs-lisp
(setq org-latex-listings t)
#+end_src

*** Selección con mayúsculas 
#+begin_src emacs-lisp
(setq org-support-shift-select t)
#+end_src

** Latex

#+begin_src emacs-lisp
(setq TeX-auto-save t)
(setq TeX-parse-self t)
(setq TeX-save-query nil)
(setq TeX-PDF-mode t)
#+end_src

Para que funcione correctamente el resaltado de sintaxis, hay que informar a Auctex de los entornos /verbatim/ utilizados:
#+begin_src emacs-lisp

(setq LaTeX-verbatim-environments
      '("verbatim" "verbatim*" "listadotxt" "PantallazoTexto" "listadosql"))
#+end_src

En Ubuntu, Evince puede sincronizarse con Emacs para saber a qué parte de código corresponde una parte del PDF y viceversa
#+begin_src emacs-lisp
(setq TeX-source-correlate-mode t)
(setq TeX-source-correlate-start-server t)
#+end_src


Modifico el comando Latex para incluir =-shell-escape=, de forma que Latex pueda arrancar programas de ayuda (por ejemplo, *Inkscape* para convertir SVG a PDF)

#+begin_src emacs-lisp
(setq LaTeX-command-style
   (quote (("" "%(PDF)%(latex) %(file-line-error) -shell-escape %(extraopts) %S%(PDFout)"))))
#+end_src


Se pueden previsualizar los entornos =tikzpicture= y =tabular= directamente en el buffer de Emacs ([[https://www.gnu.org/software/auctex/manual/preview-latex.html][https://www.gnu.org/software/auctex/manual/preview-latex.html]])

#+begin_src emacs-lisp
(eval-after-load "preview"
  '(add-to-list 'preview-default-preamble "\\PreviewEnvironment{tikzpicture}" t) )
(eval-after-load "preview"
  '(add-to-list 'preview-default-preamble "\\PreviewEnvironment{tabular}" t) )
#+end_src


** Otros /Minor modes/

Ayuda interactiva de teclado
#+begin_src emacs-lisp
(which-key-mode t)
#+end_src


Resaltar el símbolo bajo el cursor de forma dinámica. Antes lo resaltaba en todo el buffer, para que se pueda navegar por todas las ocurrencias del fichero, pero ralentizaba bastante. Ahora uso =smartscan=.
#+begin_src emacs-lisp
(require 'auto-highlight-symbol)
(setq ahs-default-range 'ahs-range-display)
#+end_src


** =helm=
=helm= es un sistema para seleccionar una opción entre varias posibilidades, que se puede usar para casi todo
- Buscar un comando
- Cambiar de buffer
- Navegar por la historia del portapapeles
- Visualizar las ocurrencias de un patrón en un buffer
- ... y más

#+begin_src emacs-lisp

;; HELM
(require 'tramp) ;; PARA EVITAR EL ERROR Symbol’s value as variable is void: tramp-methods
(setq helm-split-window-inside-p t)
(setq helm-display-header-line nil)
(setq helm-autoresize-max-height 30)
(setq helm-autoresize-min-height 30)
(setq projectile-completion-system 'helm)
(helm-autoresize-mode 1)
(helm-mode 1)
(helm-projectile-on)
(helm-flx-mode +1)
(setq helm-echo-input-in-header-line t)
(setq helm-display-buffer-reuse-frame t)
(setq helm-use-undecorated-frame-option t)
#+end_src

*** /Child frame/
=helm= se muestra en una nueva ventana. Esta ventana puede estar en una nueva /child frame/ para no cambiar la disposición de la /frame/ original. Estas opción es bastante lenta en algunos sistemas de ventanas.
#+begin_src emacs
(setq helm-display-function 'helm-display-buffer-in-own-frame
      helm-display-buffer-width 120)
#+end_src

=swiper= es un sistema de búsqueda de patrones en el buffer, con visualización simultánea de todas las ocurrencias, y también usa =helm=. Ahora estoy valorando si me quedo con =swiper= o =swop=. Lo siguiente es para hacer que también aparezca en una /child frame/.

#+begin_src lisp
(setq swiper-helm-display-function helm-display-function)
(setq helm-swoop-split-window-function helm-display-function)
#+end_src



** =multiple-cursors=
#+begin_src emacs-lisp
(setq mc/always-run-for-all t)
#+end_src




* Visualización


Cambiar el tamaño de fuente de todo /emacs/ (no solo el buffer actual)
#+begin_src emacs-lisp
(default-text-scale-mode 1)
#+end_src

Marcar la línea actual. Está deshabilitado porque no funciona bien con /overlays/
#+begin_src emacs-lisp
(global-hl-line-mode -1)
#+end_src

Respuestas de confirmación más cortas
#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

Desactivar la campana (/bell/), tanto la señal auditiva como la visual
#+begin_src emacs-lisp
(setq visible-bell 1)
(setq ring-bell-function 'ignore)
#+end_src




Utilizo /flycheck/ para que emacs compruebe automáticamente cada buffer
#+begin_src emacs-lisp
;; VALIDACIONES
(add-hook 'after-init-hook #'global-flycheck-mode)
#+end_src


El /scroll/  de /emacs/ es de media en media pantalla, heredado de los terminales modo texto que costaba refrescar. Con los ordenadores actuales, mejor un /scroll/ suave
#+begin_src emacs-lisp
(setq scroll-margin 0
      scroll-step 1
      scroll-conservatively 10000
      scroll-preserve-screen-position 1)
#+end_src

La barra de menú y la de herramientas es de lo primero que se quita al personalizar /emacs/, lo mismo que esa pantalla de inicio.
#+begin_src emacs-lisp
(setq inhibit-startup-message t)
(menu-bar-mode -1)
(tool-bar-mode -1)
#+end_src

Ancho de la página de =man=
#+begin_src emacs-lisp
(setenv "MANWIDTH" "80")
#+end_src

Muestro los paréntesis asociados al situado bajo el cursor
#+begin_src emacs-lisp
;; MOSTRAR LOS PARENTESIS ASOCIADOS
(show-paren-mode)
#+end_src

Arranco el servidor para utilizar /emacsclient/
#+begin_src emacs-lisp
(server-force-delete)
(server-start)
#+end_src

Imagex permite hace zoom en las imágenes
#+begin_src emacs-lisp
(imagex-global-sticky-mode)
(imagex-auto-adjust-mode)

#+end_src



Mi línea de estado (modeline)
#+begin_src emacs-lisp
(setq-default mode-line-format
              (list
               " "
               mode-line-modified
               " %[" mode-line-buffer-identification " %] "
               " | " '(vc-mode vc-mode)
               " | %m "
               " | %n "
               " |" mode-line-coding-system-map
               " |" mode-line-misc-info
               " | %IB %Z"
               " | %l:%c "
               mode-line-end-spaces
               ) )

#+end_src

El minimap parece una buena idea, pero no funciona demasiado bien
#+begin_src lisp
(require 'sublimity)
(require 'sublimity-map)
(require 'sublimity-attractive)
(sublimity-map-set-delay 2)
#+end_src

El ratón también puede utilizarse en un =xterm=
#+begin_src emacs-lisp
(xterm-mouse-mode)
#+end_src


* Atajos de teclado

Cuando quiero cerrar un buffer, prefiero que no pregunte.
#+begin_src emacs-lisp
(defun kill-this-buffer-dont-ask ()
  (interactive)
  (kill-buffer (current-buffer)))
(global-set-key (kbd "C-x k") 'kill-this-buffer-dont-ask)
#+end_src


En una búsqueda incremental, utilizo los cursores para ir a otras búsquedas anteriores o para navegar entre las ocurrencias en el fichero
#+begin_src emacs-lisp
  ;; TECLAS PARA ISEARCH
  (progn
    ;; set arrow keys in isearch. left/right is backward/forward, up/down is history. press Return to exit
    (define-key isearch-mode-map (kbd "<up>") 'isearch-ring-retreat )
    (define-key isearch-mode-map (kbd "<down>") 'isearch-ring-advance )

    (define-key isearch-mode-map (kbd "<left>") 'isearch-repeat-backward)
    (define-key isearch-mode-map (kbd "<right>") 'isearch-repeat-forward)

    (define-key minibuffer-local-isearch-map (kbd "<left>") 'isearch-reverse-exit-minibuffer)
    (define-key minibuffer-local-isearch-map (kbd "<right>") 'isearch-forward-exit-minibuffer))


#+end_src


A veces es fácil perderse entre comandos a medio introducir y ventanas popup. Me gusta que la tecla escape cancele cualquier acción. Con el siguiente código hago que se cancelen incluso más acciones que con =C-g=.
#+begin_src emacs-lisp
;;(define-key global-map [escape] 'keyboard-escape-quit)
;; (define-key key-translation-map (kbd "ESC") (kbd "C-g")) // PROBLEMAS CON EL TERMINAL
(defun super-escape()
  (interactive)
  (keyboard-escape-quit)
  (keyboard-quit)
  (setq quit-flag t))
(define-key global-map [escape] 'super-escape)

(define-key company-active-map [escape] 'company-abort)
#+end_src


/yasnippet/ interfiere con otros modos en su uso del tabulador, así que cambio su combinación.
#+begin_src emacs-lisp

  ;; Remove Yasnippet's default tab key binding
  (require 'yasnippet)
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)
  (define-key yas-minor-mode-map (kbd "C-c TAB") 'yas-expand)

#+end_src


Algunas teclas definidas a nivel global son sobreescritas por algunos modos (por ejemplo, prefiero que =C-Z= sea "deshacer"). Para poder definir teclas con prioridad sobre los demás modos defino un modo con mis atajos.
#+begin_src emacs-lisp

  ;; MIS TECLAS
  (defvar mis-teclas-minor-mode-map
    (let ((map (make-sparse-keymap)))
      ;(define-key map (kbd "C-i") 'some-function)
      (define-key map (kbd "C-e") 'er/expand-region)
      (define-key map (kbd "C-S-e") 'er/contract-region)
      (define-key map (kbd "C-z") 'undo )
      (define-key map (kbd "C-x C-d") 'dired)
      (define-key map (kbd "C-x d") 'dired-other-frame)
      (define-key map (kbd "C-x C-b") 'ibuffer)
      (define-key map (kbd "C-x b") 'ibuffer)
      ;(define-key map (kbd "C-f") 'swiper-helm)
      (define-key map (kbd "C-f") 'helm-swoop)
      (define-key map (kbd "C-S-f") 'helm-multi-swoop-all)
      (define-key map (kbd "C-<f5>") 'reveal-y-pdf)
      (define-key map (kbd "<backtab>") 'psw-switch-buffer)
      (define-key map (kbd "M-I") 'popup-imenu)
      (define-key map (kbd "<f7>") 'imenu-list-smart-toggle)

      (define-key map (kbd "M-S-<up>") 'enlarge-window)
      (define-key map (kbd "M-S-<down>") 'shrink-window)
      (define-key map (kbd "M-S-<left>") 'shrink-window-horizontally)
      (define-key map (kbd "M-S-<right>") 'enlarge-window-horizontally)

      (define-key map (kbd "<f5>") 'transpose-frame)

      (define-key map (kbd "<f9>") 'magit-status)

      (define-key map (kbd "<C-f2>") 'bm-toggle)
      (define-key map (kbd "<f2>")   'bm-next)
      (define-key map (kbd "<S-f2>") 'bm-previous)

      (define-key map (kbd "C-S-c C-S-c") 'mc/edit-lines)
      (define-key map (kbd "C->") 'mc/mark-next-like-this)
      (define-key map (kbd "C-<") 'mc/mark-previous-like-this)
      (define-key map (kbd "C-S-<mouse-1>") 'mc/add-cursor-on-click)
      (define-key map (kbd "C-S-c C-S-v") 'mc/mark-all-like-this)

      (define-key map (kbd "M-x") 'helm-M-x)
      (define-key map (kbd "C-x M-x") 'execute-extended-command)

      (define-key map (kbd "<menu>") 'helm-M-x)
      (define-key map (kbd "C-x C-f") 'helm-find-files)
      (define-key map (kbd "<f6>") 'helm-mini)
      (define-key map (kbd "M-y") 'helm-show-kill-ring)
      (define-key map (kbd "C-x r b") 'helm-filtered-bookmarks)

      (define-key map (kbd "<f8>") 'neotree-project-root-dir-or-current-dir)
      (define-key map (kbd "C-<f8>") 'ibuffer-sidebar-toggle-sidebar)

      (define-key map (kbd "C-x o") 'switch-window)

      (define-key map (kbd "C-o") 'dumb-jump-go)

      (define-key map (kbd "C-.") 'company-complete)

      (define-key map (kbd "C-S-l") 'toggle-truncate-lines)


      map)
    "mis-teclas-minor-mode keymap")


  (define-minor-mode mis-teclas-minor-mode
    "A minor mode so that my key settings override annoying major modes."
    :init-value t
    :lighter "mis-teclas")

  (mis-teclas-minor-mode 1)

#+end_src

#+RESULTS:
: t

* Utilidades

Convierto el buffer actual a una frame nueva
#+begin_src emacs-lisp
(defun saca-a-nueva-frame()
  (interactive)
  (let ((buffer (current-buffer)))
    (unless (one-window-p)
      (delete-window))
    (display-buffer-pop-up-frame buffer nil)))
#+end_src

#+RESULTS:
: saca-a-nueva-frame

Inicio de una selección rectangular usando el ratón (lo uso poco, prefiero =C-x spc=)
#+begin_src emacs-lisp
;; https://emacs.stackexchange.com/questions/7244/enable-emacs-column-selection-using-mouse
(defun mouse-start-rectangle (start-event)
  (interactive "e")
  (deactivate-mark)
  (mouse-set-point start-event)
  (rectangle-mark-mode +1)
  (let ((drag-event))
    (track-mouse
      (while (progn
               (setq drag-event (read-event))
               (mouse-movement-p drag-event))
        (mouse-set-point drag-event)))))

(global-set-key (kbd "S-<down-mouse-1>") #'mouse-start-rectangle)

#+end_src

Abrir el fichero del buffer actual con un programa externo
#+begin_src emacs-lisp
;; http://pages.sachachua.com/.emacs.d/Sacha.html
(defun abrir-programa-externo (arg)
  "Open visited file in default external program.

With a prefix ARG always prompt for command to use."
  (interactive "P")
  (when buffer-file-name
    (async-shell-command (concat
                          "setsid -w "
                          (cond
                           ((and (not arg) (eq system-type 'darwin)) "open")
                           ((and (not arg) (member system-type '(gnu gnu/linux gnu/kfreebsd))) "xdg-open")
                           (t (read-shell-command "Open current file with: ")))
                          " "
                          (shell-quote-argument buffer-file-name)))
    (run-at-time "2" nil
                 (lambda() (winner-undo)))))
#+end_src

Copiar el nombre del fichero actual al portapapeles
#+begin_src emacs-lisp
;; http://pages.sachachua.com/.emacs.d/Sacha.html
(defun copiar-nombre-fichero-actual ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))

#+end_src

Arrancar el servidor http de emacs en el directorio actual
#+begin_src emacs-lisp
  (defun servidor-httpd-aqui (directory host port)
    "Abre un servidor http en un directorio."
    (interactive   (list
    (read-directory-name "Root directory: " default-directory nil t)
    (read-string "Host: " "127.0.0.1" )
    (read-number "Port: " 8080)))

    (setq httpd-root directory)
    (setq httpd-host host)
    (setq httpd-port port)
    (httpd-start)
    (browse-url (concat "http://localhost:" (number-to-string port) "/")))
#+end_src


Al visitar un fichero, reabrir el bufer como root, incluso a través de tramp. Hay una versión para emacs25 y otra para emacs26.
#+begin_src emacs-lisp
(defun abrir-como-root-emacs25 ()
  "Reabre el fichero actual como root, incluso via tramp."
  (interactive)
  (let*
    ((sudo (/= (call-process "sudo" nil nil "-n true") 0))
      (file-name
        (if (tramp-tramp-file-p buffer-file-name)
          (with-parsed-tramp-file-name buffer-file-name parsed
            (tramp-make-tramp-file-name
              (if sudo "sudo" "su")
              "root"
              parsed-host
              parsed-localname
              (let ((tramp-postfix-host-format "|")
                     (tramp-prefix-format))
                (tramp-make-tramp-file-name
                  parsed-method
                  parsed-user
                  parsed-host
                  ""
                  parsed-hop))))
          (concat (if sudo
                    "/sudo::"
                    "/su::")
            buffer-file-name))))
    (find-alternate-file file-name)))


;; REABRIR COMO ROOT
(defun abrir-como-root ()
  "Reabre el fichero actual como root, incluso via tramp."
  (interactive)
  (let*
      ((sudo (/= (call-process "sudo" nil nil "-n true") 0))
       (file-name
        (if (tramp-tramp-file-p buffer-file-name)
            (with-parsed-tramp-file-name buffer-file-name parsed
              (tramp-make-tramp-file-name
               (if sudo "sudo" "su")
               "root"
               nil ; domain
               parsed-host
               nil ; port
               parsed-localname
               (let ((tramp-postfix-host-format "|")
                     (tramp-prefix-format))
                 (tramp-make-tramp-file-name
                  parsed-method
                  parsed-user
                  nil ; domain
                  parsed-host
                  nil ; PORT
                  parsed-hop))))
          
          (concat (if sudo
                      "/sudo::"
                    "/su::")
                  buffer-file-name))))
    (find-alternate-file file-name)))

#+end_src

Cuando hay que añadir muchos torrents similares, es muy útil hacerlo desde un buffer de emacs.
#+begin_src emacs-lisp
;; CONECTAR A TRANSMISSION
(defun conectar-a-transmission ()
  (interactive)

  (setq transmission-host (read-string "Transmission host: " "192.168.1.254" ))
  (setq transmission-user (read-string "Transmission user: " "transmission"))
  (setq transmission-pass (read-passwd "Transmission password: "))

  (message "Conectando a %s@%s" transmission-user transmission-host)
  
  (setq transmission-rpc-auth (list ':username transmission-user ':password transmission-pass))

  (transmission))

#+end_src

Generalmente utilizo un fichero orgmode para hacer transparencias y materiales para clase, y quiero generar a la vez las transparencias, la versión HTML y el PDF.
#+begin_src emacs-lisp
(defun reveal-y-pdf ()
  "Crea transparencias de reveal y hace el pdf a la vez."
  (interactive)
  (org-html-export-to-html)
  (let* (
         (filename (buffer-file-name))
         (html-filename (concat (file-name-sans-extension filename) ".html"))
         (html-wp-filename (concat (file-name-sans-extension filename) ".wp.html")) )
    (message "Copiando fichero: %s -> %s" html-filename html-wp-filename)
    (copy-file html-filename html-wp-filename t) )
  
  (org-reveal-export-to-html)
  (let* (
         (filename (buffer-file-name))
         (html-filename (concat (file-name-sans-extension filename) ".html"))
         (html-reveal-filename (concat (file-name-sans-extension filename) ".reveal.html")) )
    (message "renombrando fichero: %s -> %s" html-filename html-reveal-filename)
    (rename-file html-filename html-reveal-filename t))

  (org-latex-export-to-pdf)
  (let* (
         (filename (buffer-file-name))
         (tex-filename (concat (file-name-sans-extension filename) ".tex")))

    
    (message "Borrando fichero: %s" tex-filename)
    (delete-file tex-filename) ) )


#+end_src

Función para decodificar una URL
#+begin_src emacs-lisp
(defun url-decode-region (start end)
  "Replace a region with the same contents, only URL decoded."
  (interactive "r")
  (let ((text (url-unhex-string (buffer-substring start end))))
    (delete-region start end)
    (insert text)))

#+end_src

Este es mi horario lectivo (sin incluir guardias y otras horas que no son de docencia directa a alumnos)
#+begin_src emacs-lisp
(defun horario()
  (interactive)
  (cfw:open-ical-calendar "https://calendar.google.com/calendar/ical/ags.iesavellaneda%40gmail.com/private-8d8f10c04ef7daee164d8d8a8f4707d5/basic.ics"))

#+end_src

Durante una temporada, en los colegios de la Comunidad de Madrid era obligatorio el uso de un proxy.
#+begin_src emacs-lisp
(defun quitar-proxy()
  (interactive)
  (setq url-proxy-services '()))

(defun proxy-educamadrid()
  (interactive)
  (setq url-proxy-services
        '(("no_proxy" . "^\\(localhost\\|10\\.*|192\\.*\\)")
          ("http" . "213.0.88.85:8080")
          ("https" . "213.0.88.85:8080"))))

#+end_src

Inserta la imagen del portapapeles en un fichero orgmode. No lo uso mucho, quizás si cambio el nombre autogenerado sea más útil.
#+begin_src emacs-lisp
(defun org-insert-clipboard-image()
  "Save the image in the clipboard  into a time stamped unique-named file in the same directory as the org-buffer and insert a link to this file."
  (interactive)
  ; (setq tilde-buffer-filename (replace-regexp-in-string "/" "\\" (buffer-file-name) t t))
  (setq filename
        (concat
         (make-temp-name
          (concat buffer-file-name
                  "_"
                  (format-time-string "%Y%m%d_%H%M%S_")) ) ".png"))
  ;; Linux: ImageMagick:
  ;(call-process "/bin/bash" nil (list filename "kk") nil "-c" "xclip -selection clipboard -t image/png -o")
  (call-process "xclip" nil (list :file filename) nil "-selection"  "clipboard" "-t" "image/png" "-o")
  (insert (concat "[[file:" filename "]]"))
  (org-display-inline-images))
#+end_src

Eliminar el resto de buffers y ventanas
#+begin_src emacs-lisp
(defun kill-other-buffers ()
  "Kill all otherbuffers."
  (interactive)
  (mapc
   'kill-buffer
   (delq (current-buffer)
         (remove-if-not
          '(lambda (x)
             (or (buffer-file-name x)
                 (eq 'dired-mode (buffer-local-value 'major-mode  x))))
          (buffer-list)))))

#+end_src

Convertir la selección en un bloque de código de =orgmode=
#+begin_src emacs-lisp
(defun org-code-block-from-region (beg end &optional results-switches inline)
  "Copiado de org-babel-examplify-region"
  (interactive "*r")
  (let ((maybe-cap
	 (lambda (str)
	   (if org-babel-uppercase-example-markers (upcase str) str))))
    (if inline
	(save-excursion
	  (goto-char beg)
	  (insert (format org-babel-inline-result-wrap
			  (delete-and-extract-region beg end))))
      (let ((size (count-lines beg end)))
	(save-excursion
	  (cond ((= size 0))	      ; do nothing for an empty result
		(t
		 (goto-char beg)
		 (insert (if results-switches
			     (format "%s%s\n"
				     (funcall maybe-cap "#+begin_src")
				     results-switches)
			   (funcall maybe-cap "#+begin_src\n")))
		 (let ((p (point)))
		   (if (markerp end) (goto-char end) (forward-char (- end beg)))
		   (org-escape-code-in-region p (point)))
		 (insert (funcall maybe-cap "#+end_src\n")))))))))
#+end_src


Diferencias con la última versión de =git=, usando =git-gutter=
#+begin_src emacs-lisp
  (defun diferencias-git (&optional diffinfo)
    "Popup current diff hunk."
    (interactive)
    (git-gutter:awhen (or diffinfo
                          (git-gutter:search-here-diffinfo git-gutter:diffinfos))
      (save-selected-window 
        ;;(pop-to-buffer (git-gutter:update-popuped-buffer it))
        (display-buffer-pop-up-frame (git-gutter:update-popuped-buffer it) nil)
        )

      )
    )
#+end_src



* Apariencia

Mostrar líneas vacías al final del buffer, como =vim=
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'vim-empty-lines-mode)
(add-hook 'org-mode-hook 'vim-empty-lines-mode)
#+end_src

** Nivel de indentación
#+begin_src emacs-lisp
(setq highlight-indent-guides-method 'fill)
#+end_src


** Indicación de cambios de /git/
Utilizo /git/ para casi todos mis ficheros. =git-gutter= marca en el margen izquierdo las líneas cambiadas, añadidas o borradas respecto de la versión de la rama actual. indico que se refresquen los buffers cada 10 segundos.
#+begin_src emacs-lisp
(global-git-gutter-mode +1)
(setq git-gutter:update-interval 10)
#+end_src


** Saltos de página
Mostrar =^L= (saltos de página) como una línea horizontal
#+begin_src emacs-lisp
(global-page-break-lines-mode)
#+end_src

** Modo proyección o modo trabajo
Utilizo emacs de dos modos muy distintos: para trabajar y para proyectar en clase. Estas dos funciones cambian opciones de visualización adecuadas para cada ocasión.
He deshabilitado la indentación en los modos de programación, ralentiza bastante en los ficheros grandes.
#+begin_src emacs-lisp
(defun bonito-para-proyector()
  (interactive)
  (bonito-para-codigo)
  (toggle-truncate-lines -1)
  (highlight-indent-guides-mode 0)
  (if (>= emacs-major-version 26)
      (display-line-numbers-mode 0))
  (org-display-inline-images))

(defun bonito-para-org()
  (interactive)
  (bonito-para-proyector)
  (electric-pair-local-mode 1))


(defun bonito-para-codigo()
  (interactive)
  (toggle-truncate-lines 1)
  (highlight-indent-guides-mode 0)
  (toggle-word-wrap 1)
  (if (>= emacs-major-version 26)
      (display-line-numbers-mode 1))
  (auto-highlight-symbol-mode 1)
  (yafolding-mode 1)
  (adaptive-wrap-prefix-mode 1))

(add-hook 'prog-mode-hook 'bonito-para-codigo)
(add-hook 'text-mode-hook 'bonito-para-proyector)
(add-hook 'org-mode-hook 'bonito-para-org)
(add-hook 'tex-mode-hook 'bonito-para-codigo)
#+end_src


** /Fringes/
Prefiero ocultar las flechas que indican que una línea se sale de la pantalla, y solo mostrar las de la derecha.

#+begin_src emacs-lisp
(fringe-mode '(0 . nil))
#+end_src

** Temas
Tengo dos temas, claro y oscuro. El tema =alvaro= cambia algunos tamaños de letra (no colores).

Hay que marcar los temas como seguros. Para eso se deben registrar sus huellas en =custom-safe-themes= (lo he copiado del fichero =custom.el=).

#+begin_src emacs-lisp
  (setq  custom-safe-themes  (quote
  ("6e219d6b6a3f7e22888b203fd5492e12133ba40512be983858f05b42806fa573"
  "1b8d67b43ff1723960eb5e0cba512a2c7a2ad544ddb2533a90101fd1852b426e"
  "b53db91fd0153783f094a2d5480119824b008f158e07d6b84d22f8e6b063d6e2" default)))



       (defun tema-oscuro()
         (interactive)
         (disable-theme 'intellij)
         (load-theme 'sanityinc-tomorrow-bright)
         (load-theme 'alvaro t))

       (defun tema-claro ()
         (interactive)
         (disable-theme 'sanityinc-tomorrow-bright)
         (load-theme 'intellij t)
         (load-theme 'alvaro t))


#+end_src



Pongo uno detrás de otro para "limpiar" lo que haya podido quedarse de alguna customización. Por lo visto, un tema siempre añade cambios, pero al quitarse no se deshacen  completamente. Algunas configuraciones solo se tienen en cuenta al reiniciar /Emacs/ o al reaplicar un modo: por ejemplo, los colores de =highlight-indent-guides= necesitan reabrir el buffer.
#+begin_src emacs-lisp
(tema-claro)
(tema-oscuro)
#+end_src

#+RESULTS:
: t





* Futuras adiciones
En https://github.com/caisah/emacs.dz hay una colección de configuraciones /Emacs/ muy interesantes. Esta es una lista de paquetes a investigar, extraída de los que se usan en esas configuraciones
- Elfeed
- Zoom-frm
