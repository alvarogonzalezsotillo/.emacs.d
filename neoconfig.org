+TITLE: Configuración Emacs
#+author: Álvaro González (@alvarogonzalez)
#+OPTIONS: toc:2 h:4 author:t


#+latex: \newpage
#+html: <div style="margin:auto; text-align:center; font-size:1.5em">
#+latex: \begin{center}
La última versión de esta configuración puede encontrarse en [[https://github.com/alvarogonzalezsotillo/.emacs.d][https://github.com/alvarogonzalezsotillo/.emacs.d]].
#+latex: \end{center}
#+html: </div>



* Compilación de emacs
Las versiones de los sistemas operativos no suelen estar actualizadas. Mejor bajarse el repositorio git y compilarlo. Estos son los flags que uso:
#+begin_src bash
./autogen.sh
./configure --with-native-compilation --with-xml2 --with-json --with-tree-sitter --with-rsvg
make -j4
sudo make install
#+end_src

* =init.el=
Emacs comienza cargando el fichero =~/.emacs.d/init.el=. Este fichero simplemente inicializa el sistema de paquetes y carga el paquete =org=, que es el que permite a Emacs manejar este tipo de ficheros. Después, carga este fichero interpretando los bloques de código.

#+include: "~/.emacs.d/init.el" src lisp

El fichero de /customize/ lo mantengo aparte del =init.el=, para separar entornos y mejor integración con el control de versiones.
  #+begin_src emacs-lisp
  (setq custom-file "~/.emacs.d/custom-file.el")
  #+end_src

  
* Optimizaciones
  #+begin_src emacs-lisp
;; Disabling bidirectional text rendering gives a performance boost.
(setq-default bidi-display-reordering 'left-to-right
              bidi-paragraph-direction 'left-to-right)
(setq bidi-inhibit-bpa t)

;; Increase memory usage, but increase performance. No thank you, font compacting!
(setq inhibit-compacting-font-caches t)

;; Here's where we handle the GC
(use-package gcmh
  :ensure t
  :config
  (setq gcmh-idle-delay 5
        gc-cons-threshold (* 500 1024 1024) 
        gcmh-high-cons-threshold (* 1000 1024 1024))
  (gcmh-mode 1))
  #+end_src

#+begin_src emacs-lisp
(setq  native-comp-async-report-warnings-errors 'silent)

#+end_src

  
* Utilidades externas al /PATH/
En el directorio =~/.emacs.d/bin/= guardo algunas utilidades que me interesa tener en todos los entornos de trabajo. Lo siguiente es para que estén disponibles desde las /shells/ que arranque desde emacs. Las utilidades pueden consultarse en el [[https://github.com/alvarogonzalezsotillo/.emacs.d/tree/master/bin][repositorio en github]].

Añado también el directorio de =cargo= para =rust=.
#+begin_src emacs-lisp
(use-package emacs
  :config
  (let 
      (  (exec-path-separator  (if (string-equal system-type "windows-nt") ";" ":"))
         (paths `(
                  ,(concat (expand-file-name user-emacs-directory) "bin")
                  ,(concat (expand-file-name "~/") ".cargo/bin")
                  ,(concat (expand-file-name "~/") "node_modules/.bin")
                  "/opt/node/bin"
                  "/opt/scala/bin" )) )
    (dolist (path paths)
      (message "path: %s" path)
      (setenv "PATH" (concat path exec-path-separator (getenv "PATH")))
      (add-to-list 'exec-path path))

    (message "PATH %s" (getenv "PATH"))
    (message "exec-path %s" exec-path)))

#+end_src

#+RESULTS:
: t

** Abrir todos los =org= de =apuntes-clase=

#+begin_src emacs-lisp

(defun es-presentacion-p (filename)
  (let* ((contents (org-file-contents filename)))
    (string-match-p "/common/footer.org" contents)))

(defun lista-de-orgs (directory)
  (directory-files-recursively directory ".*\.org$" ))


(defun lista-de-presentaciones (directory)
  (let* ((all-orgs (lista-de-orgs directory))
         (presentations (seq-filter #'es-presentacion-p all-orgs)) )
    presentations))

(defun ags/abre-todas-las-presentaciones ()
  (interactive)
  (dolist (orgfile (lista-de-presentaciones "/home/alvaro/apuntes-clase/"))
    (find-file orgfile)
    ))


#+end_src


** Poner mi servidor de nexus en gradle
#+begin_src emacs-lisp
(defun ags/mi-servidor-nexus-en-gradle ()
  (interactive)
  (insert "
        maven {
            url \"http://localhost:8888/repository/android-group\"
            allowInsecureProtocol true
        }
"
          ))
#+end_src

** Convertir un fichero =gift= en un examen =pdf=
Tengo un proyecto personal en [[https://github.com/alvarogonzalezsotillo/grading-questionnaire]] que [[https://alvarogonzalezsotillo.github.io/blog/plantilla-latex-para-examenes/][convierte un fichero =gift= en un =pdf=]] para exámenes. Esta función me facilita la conversión.
   #+begin_src emacs-lisp

(defvar gifttolatex-titulo nil)
(defvar gifttolatex-porcentajetest nil)
(defvar gifttolatex-parametros nil)

(defun ags/gifttolatex (titulo porcentajetest parametros)
  "ejecuta giftolatex en el buffer actual."
  (interactive
   (list 
    (read-string "Título: " (or gifttolatex-titulo (buffer-name)))
    (read-number "Porcentaje del test: " (or gifttolatex-porcentajetest 60))
    (read-string "Otros parámetros:" (or gifttolatex-parametros "-k" ))))
  
  (setq gifttolatex-titulo titulo)
  (setq gifttolatex-porcentajetest porcentajetest)
  (setq gifttolatex-parametros parametros)
  
  (let ((comando (format "sh -c 'gifttolatex %s -t \"%s\" -q \"%s\" \"%s\"'" parametros titulo porcentajetest buffer-file-name)))
    (shell-command comando)))

   #+end_src


** Arrancar el servidor http de emacs en el directorio actual
#+begin_src emacs-lisp
  (defun ags/servidor-httpd-aqui (directory host port)
    "Abre un servidor http en un directorio."
    (interactive   (list
    (read-directory-name "Root directory: " default-directory nil t)
    (read-string "Host: " "127.0.0.1" )
    (read-number "Port: " 8080)))

    (setq httpd-root directory)
    (setq httpd-host host)
    (setq httpd-port port)
    (httpd-start)
    (browse-url (concat "http://localhost:" (number-to-string port) "/")))
#+end_src

** Generar /reveal/ y PDF
Generalmente utilizo un fichero orgmode para hacer transparencias y materiales para clase, y quiero generar a la vez las transparencias, la versión HTML y el PDF.
#+begin_src emacs-lisp
(defun ags/reveal-y-pdf ()
  "Crea transparencias de reveal y hace el pdf a la vez."
  (interactive)

  (save-window-excursion
    (ignore-errors
      (org-html-export-to-html)
      (let* (
             (filename (buffer-file-name))
             (html-filename (concat (file-name-sans-extension filename) ".html"))
             (html-wp-filename (concat (file-name-sans-extension filename) ".wp.html")) )
        (message "Copiando fichero: %s -> %s" html-filename html-wp-filename)
        (copy-file html-filename html-wp-filename t) ))

    (ignore-errors
      (org-re-reveal-export-to-html)
      (let* (
             (filename (buffer-file-name))
             (html-filename (concat (file-name-sans-extension filename) ".html"))
             (html-reveal-filename (concat (file-name-sans-extension filename) ".reveal.html")) )
        (message "renombrando fichero: %s -> %s" html-filename html-reveal-filename)
        (rename-file html-filename html-reveal-filename t)))

    (ignore-errors
      (org-epub-export-to-epub))

    (ignore-errors
      (org-latex-export-to-pdf)
      (let* (
             (filename (buffer-file-name))
             (tex-filename (concat (file-name-sans-extension filename) ".tex")))

        
        (message "Borrando fichero: %s" tex-filename)
        (delete-file tex-filename) ) )))
#+end_src


** Función para decodificar una URL
#+begin_src emacs-lisp
(defun ags/url-decode-region (start end)
  "Replace a region with the same contents, only URL decoded."
  (interactive "r")
  (let ((text (url-unhex-string (buffer-substring start end))))
    (delete-region start end)
    (insert text)))

#+end_src

** Convertir la selección en un bloque de código de =orgmode=
#+begin_src emacs-lisp
(defun ags/org-code-block-from-region (beg end &optional results-switches inline)
  "Copiado de org-babel-examplify-region"
  (interactive "*r")
  (let ((maybe-cap
	 (lambda (str)
	   (if org-babel-uppercase-example-markers (upcase str) str))))
    (if inline
	(save-excursion
	  (goto-char beg)
	  (insert (format org-babel-inline-result-wrap
			  (delete-and-extract-region beg end))))
      (let ((size (count-lines beg end)))
	(save-excursion
	  (cond ((= size 0))	      ; do nothing for an empty result
		(t
		 (goto-char beg)
		 (insert (if results-switches
			     (format "%s%s\n"
				     (funcall maybe-cap "#+begin_src")
				     results-switches)
			   (funcall maybe-cap "#+begin_src\n")))
		 (let ((p (point)))
		   (if (markerp end) (goto-char end) (forward-char (- end beg)))
		   (org-escape-code-in-region p (point)))
		 (insert (funcall maybe-cap "#+end_src\n")))))))))
#+end_src




* Carga de paquetes

Utilizo tres repositorios de paquetes:
- *melpa*: el más habitual
- *gnu*: me hizo falta para algo que no recuerdo, lo tengo actualmente deshabilitado.
- *org*: las versiones nuevas de org-mode se publican antes en este repositorio

** Copiar con formatos

#+begin_src emacs-lisp
(use-package copy-as-format
  :ensure t)

#+end_src

** =straight=

#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 6))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

#+RESULTS:
: t

** =use-package=

=use-package= es una utilidad para la carga y configuración de paquetes con las siguientes ventajas:
- Puede definir dependencias entre paquetes (=requires= y =after=)
- Permite la carga diferida, lo que acelera el arranque y el uso de memoria
- Agrupa la configuración de cada paquete
- Instala el paquete si no está instalado





** =centaur-tabs=
#+begin_src emacs-lisp
(use-package centaur-tabs
  :ensure t
  :defer 1
  :init
  (setq centaur-tabs-enable-key-bindings t)
  :config

  (defun ags/centaur-tabs-font-sizes (&optional height)
    (interactive
     (list 
      (read-number "height: " 0.9)))

    (mapcar
     (lambda (face) (set-face-attribute face nil :height (or height 100)) )
     '(
       centaur-tabs-active-bar-face
       centaur-tabs-default
       centaur-tabs-unselected
       centaur-tabs-selected
       centaur-tabs-unselected-modified
       centaur-tabs-selected-modified
       centaur-tabs-close-unselected
       centaur-tabs-close-selected
       centaur-tabs-close-mouse-face
       centaur-tabs-modified-marker-selected
       centaur-tabs-modified-marker-unselected
       ))

    (setq centaur-tabs-height 40)
    (setq centaur-tabs-bar-height (+ 8 centaur-tabs-height)))


  (setq centaur-tabs-set-icons t)
  (setq centaur-tabs-style "alternate")
  (setq centaur-tabs-set-modified-marker t)
  (setq centaur-tabs-gray-out-icons 'buffer)
  (setq centaur-tabs-set-bar 'over)
  (setq centaur-tabs-cycle-scope 'tabs)
  (setq centaur-tabs-show-navigation-buttons t)
  (setq centaur-tabs-hide-tabs-hooks '(reb-mode-hook completion-list-mode-hook))

  (ags/centaur-tabs-font-sizes)

  (centaur-tabs-mode t)
  (centaur-tabs-group-by-projectile-project)


)
#+end_src



** =diff-hl=
Utilizo /git/ para casi todos mis ficheros. =diff-hl=  marca en el margen izquierdo las líneas cambiadas, añadidas o borradas respecto de la versión de la rama actual. 

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :defer 1
    :ensure t
    :straight (:host github :repo "dgutov/diff-hl")
    :config

    (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
    (global-diff-hl-mode 1))

  (use-package diff-hl-margin
    :after diff-hl)


  (use-package diff-hl-dired
    :after diff-hl
    :config
    (diff-hl-dired-mode 1))

  (use-package diff-hl-flydiff
    :after diff-hl
    :config
    (diff-hl-flydiff-mode 1))

  (use-package diff-hl-show-hunk
    :after diff-hl
    :config
    (require 'diff-hl-show-hunk-posframe)

    (defun ags/diff-hl-show-hunk-toggle-backend()
      (interactive)
      (setq diff-hl-show-hunk-posframe-poshandler 'posframe-poshandler-point-window-center)
      (if (eq diff-hl-show-hunk-function 'diff-hl-show-hunk-posframe)
	  (setq diff-hl-show-hunk-function 'diff-hl-show-hunk-inline-popup)
	(setq diff-hl-show-hunk-function 'diff-hl-show-hunk-posframe)))

    (defun ags/diff-hl-show-hunk-toggle-style()
      (interactive)
      (if diff-hl-show-hunk-inline-popup-hide-hunk
	  (progn
	    (setq diff-hl-show-hunk-inline-popup-hide-hunk nil)
	    (setq diff-hl-show-hunk-inline-popup-smart-lines t))
	(setq diff-hl-show-hunk-inline-popup-hide-hunk t)
	(setq diff-hl-show-hunk-inline-popup-smart-lines nil)))

    (setq diff-hl-show-hunk-inline-popup-hide-hunk t)
    (setq diff-hl-show-hunk-inline-popup-smart-lines nil)

    (global-diff-hl-show-hunk-mouse-mode 1))



#+END_SRC


** =page-break-lines=
Mostrar =^L= (saltos de página) como una línea horizontal
#+begin_src emacs-lisp
(use-package page-break-lines
  :defer t
  :ensure t
  :config
  (global-page-break-lines-mode 1))
#+end_src

** =gift-mode=
#+begin_src emacs-lisp
(use-package gift-mode
  :defer t
  :ensure t
  :bind
      (("C-c C-c" . ags/gifttolatex))

  :config
  (defalias 'trim-string 'string-trim) 
  
)
#+end_src



#+begin_src lisp
(use-package origami-predef
  :ensure t
  :defer 1
  :after (origami)
  :config

  (origami-predef-global-mode 1)

  (defun origami-predef-javascript()
    "Close some predefined patterns, useful in javascript."
    (interactive)
    (origami-predef-apply-patterns (list
                                    "^\\s-*[[:alnum:]]+([()[:alnum:], >=]*)\\s-*{"
                                    "^\\s-*function\\s-*[[:alnum:]]+([()[:alnum:], >=]*)\\s-*{"
                                    )))
  ;;(add-hook 'js2-mode-hook #'origami-predef-javascript)

  (defun ags/origami-predef-lisp()
    "Close some predefined patterns, useful in elisp."
    (interactive)
    (origami-predef-apply-patterns '("defcustom" "defvar" "defface" "defgroup" "defun .*--")))
  ;;(add-hook 'emacs-lisp-mode-hook #'ags/origami-predef-lisp)

  (defun ags/origami-predef-java()
    "Close some predefined patterns, useful in java."
    (interactive)
    (origami-predef-apply-patterns '("private .*{" "protected .*{")))
  ;;(add-hook 'java-mode-hook #'ags/origami-predef-java)

  (defun ags/origami-predef-sql()
    "Close some predefined patterns, useful in SQL."
    (interactive)
    (origami-predef-apply-patterns '("create .*table" "create .*view" "begin")))
  ;;(add-hook 'sql-mode-hook #'ags/origami-predef-sql)


  (defun ags/origami-predef-gift()
    "Close some predefined patterns, useful in gift-mode (https://github.com/csrhodes/gift-mode)"
    (interactive)
    (origami-predef-apply-patterns "{" ))
  (add-hook 'gift-mode-hook #'ags/origami-predef-gift)
  
  (origami-predef-global-mode 1))
#+end_src

** =quickrun=
=Quickrun= ejecuta el buffer actual. Aumento el tiempo límite de la ejecución antes de matar el proceso.
#+begin_src emacs-lisp
(use-package quickrun
  :ensure t
  :config 
    (setq quickrun-timeout-seconds 100))
#+end_src
** =htmlize=

#+begin_src emacs-lisp
(use-package  htmlize
  :ensure t
  :defer 1
  :config
 (setq htmlize-force-inline-images t)
 (setq htmlize-output-type 'inline-css)
)
#+end_src


** =expand-region=
#+begin_src emacs-lisp
(use-package expand-region
  :ensure t
  :defer 1
  :bind
      (( "C-e" . 'er/expand-region))
      (( "C-S-e" . 'er/contract-region))
      (( "M-<up>" . 'er/expand-region))
      (( "M-<down>" . 'er/contract-region))
)
#+end_src


** =sudo-edit=
   #+begin_src emacs-lisp
(use-package sudo-edit
  :ensure t
  :defer 1
  :config
  (defun abrir-como-root()
    (interactive)
    (sudo-edit))
)

   #+end_src

** =helpful=

#+begin_src emacs-lisp
(use-package helpful
  :ensure t
  :bind
  ([remap describe-symbol]      . helpful-symbol)
  ([remap describe-callable]    . helpful-callable)
  ([remap describe-function]    . helpful-function)
  ([remap describe-variable]    . helpful-variable)
  ([remap describe-key]         . helpful-key)
  ([remap view-emacs-debugging] . helpful-at-point)

)
#+end_src


** =magit=

   #+begin_src emacs-lisp
(use-package magit
  :ensure t
  :defer 1
  :bind
  (("<f9>" . magit-status)
   ("C-x g" . magit-status)
   ("M-<f9>" . magit-dispatch))

  :config
  (remove-hook 'magit-status-sections-hook 'magit-insert-tags-header)
  (remove-hook 'magit-status-sections-hook 'magit-insert-unpushed-to-pushremote)
  (remove-hook 'magit-status-sections-hook 'magit-insert-unpulled-from-pushremote)
  (remove-hook 'magit-status-sections-hook 'magit-insert-unpulled-from-upstream)
  (remove-hook 'magit-status-sections-hook 'magit-insert-unpushed-to-upstream-or-recent)

  (setq magit-diff-refine-hunk 'all)

  (use-package abridge-diff
    :ensure t
    :defer 1
    :after magit ;; optional, if you'd like to use with magit
    :init (abridge-diff-mode 1))

  (use-package magit-todos
    :ensure t
    :defer 1
    :config
    (setq magit-todos-scanner 'magit-todos--scan-with-git-grep)
    (setq magit-todos-auto-group-items 'always)
    (setq magit-todos-exclude-globs
          '(".git/" "common/reveal.js*"
            "**/jquery-ui*"
            "**/qrcode.sty"
            "common/mathjax/"
            "themes/alvaro/resources/"
            "site.educa.madrid.org/ies.alonsodeavellan.alcala/"
            "charlas-motivacionales/informatica/1/reveal.js/plugin/markdown/plugin.js"
            "**/reveal.js*"))

    (magit-todos-mode 1)
    )

  (use-package vdiff-magit
    :ensure t
    :defer 1
    :config

    (define-key magit-mode-map "e" 'vdiff-magit-dwim)
    (define-key magit-mode-map "E" 'vdiff-magit)
    (transient-suffix-put 'magit-dispatch "e" :description "vdiff (dwim)")
    (transient-suffix-put 'magit-dispatch "e" :command 'vdiff-magit-dwim)
    (transient-suffix-put 'magit-dispatch "E" :description "vdiff")
    (transient-suffix-put 'magit-dispatch "E" :command 'vdiff-magit)

    ;; This flag will default to using ediff for merges.
    (setq vdiff-magit-use-ediff-for-merges nil)

    ;; Whether vdiff-magit-dwim runs show variants on hunks.  If non-nil,
    ;; vdiff-magit-show-staged or vdiff-magit-show-unstaged are called based on what
    ;; section the hunk is in.  Otherwise, vdiff-magit-dwim runs vdiff-magit-stage
    ;; when point is on an uncommitted hunk.
    ;; (setq vdiff-magit-dwim-show-on-hunks nil)

    ;; Whether vdiff-magit-show-stash shows the state of the index.
    ;; (setq vdiff-magit-show-stash-with-index t)

    ;; Only use two buffers (working file and index) for vdiff-magit-stage
    (setq vdiff-magit-stage-is-2way nil)
    )



  
  )
   #+end_src

   #+RESULTS:
   : magit-dispatch

Para instalar magit-delta
- https://scripter.co/using-git-delta-with-magit/
- https://dandavison.github.io/delta/configuration.html  

#+begin_src lisp
  (use-package magit-delta
    :ensure t
    :hook (magit-mode . magit-delta-mode))
#+end_src


   
** =mode-icons=
Cambia la descripción del modo por un icono en la modeline
   #+begin_src emacs-lisp
(use-package mode-icons
  :defer 1
  :ensure t
  :config
  (mode-icons-mode 1)
)
   #+end_src


** =imenu=
Reduzco el tamaño de todas las fuentes de =imenu=
   #+begin_src emacs-lisp
(use-package imenu-list
  :defer 1
  :ensure t
  :bind
  (("<f7>" . imenu-list-smart-toggle))
  :config 
   (set-face-attribute 'imenu-list-entry-face nil :height  0.8)
   (add-hook 'imenu-list-major-mode-hook (lambda () (message "IMENU MAJOR MODE")(display-line-numbers-mode 1))))

(use-package popup-imenu
  :defer 1
  :ensure t     
  :bind
  (("M-I" . popup-imenu)))
#+end_src

#+RESULTS:
: popup-imenu


   
** =blamer=
Muestra el autor del último cambio, y si se pincha muestra los cambios de ese commit.

   
   #+begin_src emacs-lisp
(use-package blamer
  :defer 1
  :ensure t
  :config
  (setq blamer-view 'overlay-right)
  (setq blamer-tooltip-function 'blamer-tooltip-keybindings)

  (defun ags/blamer-callback-show-commit-diff (commit-info)
    (interactive)
    (let ((commit-hash (plist-get commit-info :commit-hash)))
      (when commit-hash
        (magit-show-commit commit-hash))))

  (defun ags/blamer-callback-magit-log-file (commit-info)
    (interactive)
    (magit-log-buffer-file)
    (let ((commit-hash (plist-get commit-info :commit-hash)))
      (when commit-hash
        ;; For some reason, only works after a while
        (run-with-idle-timer 0.01 nil (lambda (commit-hash)
                                     (goto-char (point-min))
                                     (search-forward (substring commit-hash 0 7))
                                     (recenter)
                                     (pulse-momentary-highlight-one-line))
                             commit-hash))))

  (defun ags/blamer-callback-timemachine (commit-info)
    (interactive)
    (git-timemachine))

  (set-face-attribute 'blamer-face nil :height 0.7) 
  (setq blamer-bindings '(("<mouse-1>" . ags/blamer-callback-magit-log-file)
                          ("<mouse-2>" . ags/blamer-callback-show-commit-diff)
                          ("<mouse-3>" . ags/blamer-callback-timemachine)))
  )
   #+end_src

   
** =multiple-cursors=

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :custom (mc/always-run-for-all t)
    :bind

      (("C-S-c C-S-c" . mc/edit-lines ))
      (("C->" . mc/mark-next-like-this ))
      (("C-<" . mc/mark-previous-like-this ))
      (("C-S-<mouse-1>" . mc/add-cursor-on-click ))
      (("C-S-c C-S-v" . mc/mark-all-like-this ))
)
#+END_SRC


** =demap=
Muestra un /minimap/ del fichero
#+begin_src emacs-lisp
(use-package demap
  :ensure t
  :straight (:host gitlab :repo "sawyerjgardner/demap.el")
  :defer 1
  :bind
  (( "C-S-<f7>" . demap-toggle))
  :config
)
#+end_src

#+RESULTS:
: demap-toggle

** =all-the-icons=
#+begin_src emacs-lisp
(use-package all-the-icons
  :ensure t
  :defer t)
(use-package all-the-icons-dired
  :ensure t
  :defer t)
#+end_src


** =dired=, =dired-ranger=, =dired-subtree=
Coloco primero los directorios, y hago que la tecla =Tab= abra un subárbol

#+begin_src emacs-lisp

    (use-package casual-dired
      :ensure t
      :bind
      (:map dired-mode-map ("C-o" . 'casual-dired-tmenu))
      (:map dired-mode-map ("h" . 'casual-dired-tmenu)))

    (use-package openwith
      :ensure t
      :defer 1
      :config
      (openwith-mode t)
      (setq openwith-associations '(("\\.pdf\\'" "okular" (file)))))

    (use-package dired-aux
      :config
      ;; Default action to open any file
      (when (boundp 'dired-guess-shell-alist-default)
        (add-to-list 'dired-guess-shell-alist-default ' ("\\.pdf\\'" "okular") t)))

    (use-package dired-x)

    ;; Copy and paste files
    (use-package dired-ranger
      :ensure t
      :defer t
      :bind (:map dired-mode-map
		  ("W" . dired-ranger-copy)
		  ("X" . dired-ranger-move)
		  ("Y" . dired-ranger-paste)))

    (use-package dired
      :config
      (setq dired-kill-when-opening-new-dired-buffer nil)

      (setq dired-listing-switches "-aBhl --group-directories-first")


      (defun ags/dired-hook ()
	(interactive)
	(if (file-remote-p default-directory)
	    (all-the-icons-dired-mode -1)
	   (all-the-icons-dired-mode 1))
	(dired-hide-details-mode 1)
	(auto-revert-mode 1)
	(diff-hl-dired-mode 1)
	(setq  indent-line-function 'dired-subtree-toggle))

      (add-hook 'dired-mode-hook 'ags/dired-hook)
      )

    (use-package dired-subtree 
      :ensure t
      :defer 1
      :config

      (set-face-attribute 'dired-subtree-depth-1-face nil :background 'unspecified)
      (set-face-attribute 'dired-subtree-depth-2-face nil :background 'unspecified)
      (set-face-attribute 'dired-subtree-depth-3-face nil :background 'unspecified)
      (set-face-attribute 'dired-subtree-depth-4-face nil :background 'unspecified)
      (set-face-attribute 'dired-subtree-depth-5-face nil :background 'unspecified)
      (set-face-attribute 'dired-subtree-depth-6-face nil :background 'unspecified)

      )


#+end_src

#+RESULTS:
: t


** =good-scroll=
El /scroll/  de /emacs/ es de media en media pantalla, heredado de los terminales modo texto que costaba refrescar. Con los ordenadores actuales, mejor un /scroll/ suave
#+begin_src emacs-lisp
(use-package good-scroll
  :ensure t
  :config
  (good-scroll-mode 1))


#+end_src


#+begin_src emacs-lisp
(setq scroll-error-top-bottom t)
#+end_src


** =flycheck=
Marca errores en el fichero

#+begin_src emacs-lisp
(use-package flycheck
  :defer 1
  :ensure t
  :config
  (setq flycheck-shellcheck-follow-sources t)
  (global-flycheck-mode 1))
#+end_src

Ya no uso =flycheck-inline=, ahora uso =sideline=

#+begin_src lisp
  (use-package flycheck-inline
    :ensure t
    :defer 1
    :config
    (global-flycheck-inline-mode 1)
  )
#+end_src

#+begin_src emacs-lisp
  (use-package flycheck-pos-tip
    :ensure t
    :defer 1
    :config
    (flycheck-pos-tip-mode 1)
  )
#+end_src

#+RESULTS:

** =flycheck-hl-todo=
#+begin_src emacs-lisp
(use-package flycheck-hl-todo
  :ensure t
  :defer 5 ; Need to be initialized after the rest of checkers
  ;;:straight (:host github :repo "alvarogonzalezsotillo/flycheck-hl-todo")
  :config
  (flycheck-hl-todo-setup))
#+end_src  

#+RESULTS:


** =simple-httpd=
Añado algunos /mime-type/ al servidor HTTP
#+BEGIN_SRC emacs-lisp
(use-package simple-httpd
  :defer 1
  :ensure t
  :config
  (add-to-list 'httpd-mime-types '("mjs" . "text/javascript") )
  (add-to-list 'httpd-mime-types '("wasm" . "application/wasm") )
  )
#+END_SRC

** =treemacs=
Estoy usando =treemacs= en vez de =neotree=.


#+begin_src emacs-lisp

(use-package treemacs
  :ensure t
  :defer 1
  :config

  ;; https://github.com/doomemacs/doomemacs/issues/3046
  (add-to-list 'image-types 'svg)

  (defun ags/hacer-treemacs-resizable ()
    (if treemacs--width-is-locked
        (treemacs-toggle-fixed-width)))

  (defun ags/cambiar-faces-de-treemacs ()
    ;; Cambio el tamaño por defecto del face
    (mapcar
     (lambda (face) (set-face-attribute face nil :height 0.7) )
     '(
       treemacs-directory-face                
       treemacs-directory-collapsed-face      
       ;;treemacs-file-face                     
       treemacs-root-face                     
       treemacs-root-unreadable-face          
       treemacs-root-remote-face              
       treemacs-root-remote-unreadable-face   
       treemacs-root-remote-disconnected-face 
       treemacs-tags-face                     
       treemacs-help-title-face               
       treemacs-help-column-face              
       treemacs-git-unmodified-face
       treemacs-git-modified-face
       treemacs-git-renamed-face
       treemacs-git-ignored-face
       treemacs-git-untracked-face
       treemacs-git-added-face
       treemacs-git-conflict-face
       treemacs-term-node-face                
       treemacs-on-success-pulse-face         
       ))
    )

  (setq treemacs-indentation 1)
  
  (defun ags/treemacs-toggle ()
    (interactive)
    (if (eq (treemacs-current-visibility) 'visible)
        (delete-window (treemacs-get-local-window))
      (let (filename (buffer-file-name))
        
        (treemacs-add-and-display-current-project-exclusively)
        (when filename
          (treemacs-find-file filename)
          )
        )
      ))
  
  (add-hook 'treemacs-mode-hook #'ags/hacer-treemacs-resizable)
  (setq treemacs-silent-refresh t)
  (treemacs-git-mode -1)
  (treemacs-follow-mode 1)
  
  (ags/cambiar-faces-de-treemacs)
  
  :bind
  (("<f8>" . ags/treemacs-toggle))
  )
#+end_src


** =dumb-jump=
Añado las siguientes reglas para hacer búsquedas simples con =dumb-jump= en ficheros =sql= y =org=.
#+begin_src emacs-lisp
  ;; ADITIONAL DUMBJUMB RULES
  (use-package dumb-jump
    :ensure t
    :config

  ;;   (add-to-list 'dumb-jump-find-rules
  ;;                '(:type "something" :supports ("ag" "grep" "rg" "git-grep") :language "sql"
  ;;                        :regex ": \\bJJJ\\j"))
  ;;   (add-to-list 'dumb-jump-find-rules
  ;;                '(:type "something" :supports ("ag" "grep" "rg" "git-grep") :language "org"
  ;;                        :regex ": \\bJJJ\\j"))
  ;;   (add-to-list 'dumb-jump-language-file-exts
  ;;                '(:language "javascript" :ext "mjs" :agtype "js" :rgtype "js")))


  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+end_src


** =projectile=
=projectile= necesita conocer su tecla de prefijo (utilizo la tradicional).
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    (setq projectile-switch-project-action 'projectile-dired)
    (setq projectile-indexing-method 'alien)
    (setq projectile-enable-caching t)

    (projectile-mode 1)
    (setq projectile-switch-project-action 'projectile-dired)

    (use-package ibuffer-projectile
      :ensure t
      :defer 1
      :config
      (add-hook 'ibuffer-hook #'ibuffer-projectile-set-filter-groups)
      (add-hook 'ibuffer-sidebar-mode-hook #'ibuffer-projectile-set-filter-groups)
      (add-hook 'ibuffer-mode-hook (lambda () (ibuffer-auto-mode 1)))
      )
    )


#+end_src







** =ox-epub=
Para crear libros electrónicos a partir de org
#+begin_src emacs-lisp
(use-package ox-epub
  :ensure t
  :defer 1)
#+end_src


** =org-re-reveal=
#+begin_src emacs-lisp
(use-package org-re-reveal
  :ensure t
  :config
)
#+end_src

** =visual-regexp=

#+begin_src emacs-lisp
(use-package visual-regexp
  :defer 1
  :ensure t
  :bind
  (( "C-M-%" . vr/query-replace))
  )
#+end_src

  



** =dead-grep=
#+begin_src emacs-lisp
(use-package deadgrep
  :ensure t
  :defer 1
  :config )
#+end_src

** =Popwin=
Algunas ventanas tienen menor /importancia/ que otras, ya que tienden a ser temporales (por ejemplo, las ventanas de ayuda). Con =popwin=, estas ventanas ocupan menos espacio en pantalla y desaparecen con =C-g=. Actualmente lo he quitado.
#+begin_src lisp
(use-package popwin
  :ensure t
  :defer 1
  :config
    (popwin-mode 1))
#+end_src

** =winner=
Retroceder en la historia de disposición de ventanas y búferes
#+begin_src emacs-lisp
(use-package winner
  :ensure t
  :defer 1 
  :config
    (setq winner-dont-bind-ags/keys nil)
    (winner-mode 1)
    (define-key winner-mode-map (kbd "M-<left>") #'winner-undo)
    (define-key winner-mode-map (kbd "M-<right>") #'winner-redo))
#+end_src

** =region-occurrences-highlighter=
Marcar las ocurrencias de la selección
#+begin_src emacs-lisp
  (use-package region-occurrences-highlighter 
    :ensure t
    :straight (:host github :repo "alvarogonzalezsotillo/region-occurrences-highlighter")
    :defer 1
    :config
    (global-region-occurrences-highlighter-mode 1)
    (setq region-occurrences-highlighter-max-size 3000)
    (define-key region-occurrences-highlighter-nav-mode-map "\M-n" 'region-occurrences-highlighter-next)
    (define-key region-occurrences-highlighter-nav-mode-map "\M-p" 'region-occurrences-highlighter-prev)
    (define-key region-occurrences-highlighter-nav-mode-map (kbd "<wheel-down>") 'region-occurrences-highlighter-next)
    (define-key region-occurrences-highlighter-nav-mode-map (kbd "<wheel-up>") 'region-occurrences-highlighter-prev))
#+end_src

#+RESULTS:
: region-occurrences-highlighter-prev


** =breadcrumb-mode=
Marcar las ocurrencias de la selección. Lo quito porque salen mensajes de error.
#+begin_src lisp
  (use-package breadcrumb
    :ensure t
    :straight (:host github :repo "joaotavora/breadcrumb")
    :defer 1)
#+end_src

#+RESULTS:


** =smartscan=
Utilizo =smartscan= para localizar ocurrencias de símbolos.
Las teclas rápidas son M-n y M-p, que entran en conflicto con las de region-occurrences-highlighter-nav-mode-map.
Cargo este paquete después para que en minor-mode-map-alist aparezca antes el keymap de region-occurrences.
#+begin_src emacs-lisp
(use-package smartscan
  :ensure t
  :defer 1
  :config
    (setq smartscan-symbol-selector "symbol")
    (global-smartscan-mode 1))
#+end_src

** =vertico=


#+begin_src emacs-lisp

(use-package marginalia
  :ensure t
  :defer 1
  :custom
  (marginalia-max-relative-age 0)
  (marginalia-align 'right)
  :init
  (marginalia-mode))


(use-package all-the-icons-completion
  :ensure t
  :defer 1
  :after (marginalia all-the-icons)
  :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
  :init
  (all-the-icons-completion-mode))

(use-package vertico
  :ensure t
  :defer 1
  :custom
  (vertico-count 13)                    ; Number of candidates to display
  (vertico-resize nil)
  (vertico-cycle nil) ; Go from last to first candidate and first to last (cycle)?

  :config
  (vertico-mode))

(use-package vertico-mouse
  :ensure nil
  :config
  (vertico-mouse-mode 1)
  )

(use-package vertico-posframe
  :after vertico
  :ensure t
  :defer 1
  :config
  (setq vertico-posframe-border-width 6)

  ;;(setq vertico-posframe-poshandler #'ags/posframe-poshandler-right-verticaly-centered)
  (setq vertico-posframe-poshandler #'posframe-poshandler-frame-bottom-center)
  
  (when (posframe-workable-p)
    (vertico-posframe-mode 1)))


(use-package orderless
  :ensure t
  :defer 1
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))


(use-package consult
  :after projectile
  :ensure t
  :defer 1
  :bind
  (("<f6>"  . consult-buffer)
   ("C-x r b" . consult-bookmark)
   ("M-y" . consult-yank-pop)
   ("M-g g" . consult-goto-line)
   ("C-f" . consult-line)
   ("C-S-f" . consult-line-multi)
   ("M-<f7>" . consult-imenu )
   )

  :config
  ;;(define-key minibuffer-mode-map (kbd "S-<f6>") 'previous-line-or-history-element)
  ;;(define-key minibuffer-mode-map (kbd "<f6>") 'next-line-or-history-element)
  (define-key projectile-command-map (kbd "s g") 'consult-git-grep)
  )

(use-package consult-projectile
  :ensure t
  :defer 1
  :after projectile

  :bind
  (("C-<f6>"  . consult-projectile-switch-to-buffer) )

  :config
  (setq consult-projectile-use-projectile-switch-project t)
  (setq xref-show-xrefs-function #'consult-xref)
  (setq xref-show-definitions-function #'consult-xref)
  (setq consult-narrow-key "<")
  (setq consult-widen-key ">")
  (define-key projectile-command-map (kbd "f") #'consult-projectile-find-file)
  ;;(define-key projectile-command-map (kbd "p") #'consult-projectile-switch-project) ;; MIENTRAS SE QUEDE ENGANCHADO CON TRAMP
  (define-key projectile-command-map (kbd "p") #'projectile-switch-project) ;; MIENTRAS SE QUEDE ENGANCHADO CON TRAMP
  (define-key projectile-command-map (kbd "s s") #'consult-ripgrep)
  )


(use-package embark
  :ensure t

  :bind
  (("C-ñ" . embark-act)         ;; pick some comfortable binding
   ("C--" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init

  ;; Optionally replace the key help with a completing-read interface
  ;; (setq prefix-help-command #'embark-prefix-help-command)

  ;; Show the Embark target at point via Eldoc. You may adjust the
  ;; Eldoc strategy, if you want to see the documentation from
  ;; multiple providers. Beware that using this can be a little
  ;; jarring since the message shown in the minibuffer can be more
  ;; than one line, causing the modeline to move up and down:

  ;; (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
  ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

  :config

  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :ensure t ; only need to install it, embark loads it after consult if found
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))

#+end_src

#+RESULTS:
| embark-consult--upgrade-markers | consult-preview-at-point-mode |


** =helm=
=helm= es un sistema para seleccionar una opción entre varias posibilidades, que se puede usar para casi todo
- Buscar un comando
- Cambiar de buffer
- Navegar por la historia del portapapeles
- Visualizar las ocurrencias de un patrón en un buffer
- ... y más

#+begin_src lisp
  ;; HELM
  (use-package helm
    :ensure t
    :defer 1
    :config
    (setq helm-split-window-inside-p t)
    (setq helm-display-header-line nil)
    (setq helm-autoresize-max-height 40)
    (setq helm-autoresize-min-height 30)
    (setq helm-autoresize-min-width 100)
    (helm-autoresize-mode 1)
    (helm-mode 1)
    (helm-flx-mode +1)
    (setq helm-display-buffer-reuse-frame t)
    (setq helm-use-undecorated-frame-option t)

    ;;(setq helm-display-function 'helm-display-buffer-in-own-frame)
    ;;(setq helm-display-buffer-width 120)

    ;; PROBLEMAS DE REDISPLAY: hasta que no doy una tecla no se muestra nada
    ;;(defun ags/try-to-redisplay-helm ()
    ;;  (redisplay t))
    ;;(add-hook 'helm-minibuffer-set-up-hook 'ags/try-to-redisplay-helm)

    (defun ags/helm-hook()
      (setq helm-truncate-lines t))

    (add-hook 'helm-major-mode-hook #'ags/helm-hook)
    
    (use-package dumb-jump
      :config
      (setq dumb-jump-selector 'helm)
      )

    (use-package helm-projectile
      :ensure t
      :defer 1
      :config 
      (helm-projectile-on)
      (setq projectile-completion-system 'helm)
      )

    (use-package helm-swoop
      :ensure t
      :config
      (setq helm-display-buffer-width 140)
      (setq helm-display-buffer-height 20)
      (setq helm-swoop-split-window-function helm-display-function)
      :after (helm)
      :bind
	  (("C-f" . helm-swoop))
	  (("C-S-f" . helm-multi-swoop-all))
    )

    :bind
    (("M-x"  . helm-M-x))
    (("<menu>"  . helm-M-x))
    (("C-x C-f"  . helm-find-files))
    (("<f6>"  . helm-mini))
    (("M-y"  . helm-show-kill-ring))
    (("C-x r b"  . helm-filtered-bookmarks))

    :config
    (add-to-list 'helm-commands-using-frame #'helm-M-x)

    )
#+end_src

#+RESULTS:
: helm-filtered-bookmarks

#+begin_src lisp
    ;;https://www.reddit.com/r/emacs/comments/345vtl/make_helm_window_at_the_bottom_without_using_any/
    ;;HELM SIEMPRE ABAJO CON ANCHO COMPLETO
    (add-to-list 'display-buffer-alist
                    `(,(rx bos "*helm" (* not-newline) "*" eos)
                         (display-buffer-in-side-window)
                         (inhibit-same-window . t)
                         (window-height . 0.3)))
#+end_src









** =expand-region=
#+begin_src emacs-lisp
(use-package expand-region
  :ensure t
  :defer 1
  :bind
      (( "C-e" . 'er/expand-region))
      (( "C-S-e" . 'er/contract-region))
      (( "M-<up>" . 'er/expand-region))
      (( "M-<down>" . 'er/contract-region))
)
#+end_src

** =bm=
Siempre me gustaron los /bookmarks/ dentro de un fichero de Microsoft Visual C++
#+BEGIN_SRC emacs-lisp
(defun my/bookmark-or-edit ()
  (interactive)

  (if (string= major-mode "dired-mode")
      (progn
        (all-the-icons-dired-mode -1)
        (wdired-change-to-wdired-mode))
    (bm-next)))


(use-package bm
  :ensure t
  :bind
  (( "<C-f2>" . bm-toggle))
  (( "<f2>" . my/bookmark-or-edit ))
  (( "<S-f2>" . bm-previous))

  :config
  ;; https://github.com/joodland/bm/issues/45
  (defun bm-lists (&optional direction predicate)
    "Return a pair of lists giving all the bookmarks of the current buffer.
The car has all the bookmarks before the overlay center;
the cdr has all the bookmarks after the overlay center.
A bookmark implementation of `overlay-lists'.

If optional argument DIRECTION is provided, only return bookmarks
in the specified direction.

If optional argument PREDICATE is provided, it is used as a
selection criteria for filtering the lists."
    (if (null predicate)
        (setq predicate 'bm-bookmarkp))

    (overlay-recenter (point))
    (cond ((equal 'forward direction)
           (cons nil (remq nil (mapcar predicate (overlays-in (point) (point-max))))))
          ((equal 'backward direction)
           (cons (remq nil (mapcar predicate (overlays-in (point-min) (point)))) nil))
          (t
           (cons
            (remq nil (mapcar predicate (overlays-in (point-min) (point))))
            (remq nil (mapcar predicate (overlays-in (point) (point-max))))))))
  
  )
#+END_SRC


** =indent-bars=

#+begin_src emacs-lisp
(use-package indent-bars
  :ensure t
  :straight (indent-bars :type git :host github :repo "jdtsmith/indent-bars"))
#+end_src
** =multiple-cursors=

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :custom (mc/always-run-for-all t)
    :bind

      (("C-S-c C-S-c" . mc/edit-lines ))
      (("C->" . mc/mark-next-like-this ))
      (("C-<" . mc/mark-previous-like-this ))
      (("C-S-<mouse-1>" . mc/add-cursor-on-click ))
      (("C-S-c C-S-v" . mc/mark-all-like-this ))
)
#+END_SRC


** =which-key=

Ayuda interactiva de teclado. En el popup-type por defecto entra en conflicto con treemacs.
#+begin_src emacs-lisp
(use-package which-key
  :ensure t
  :config
    (which-key-mode t)
    (setq which-key-idle-delay 3.0)
)

(use-package which-key-posframe
  :ensure t
  :config
  (setq which-key-posframe-border-width 6)
  (which-key-posframe-mode)

)
#+end_src

** =auto-highlight-symbol=
Resaltar el símbolo bajo el cursor de forma dinámica. Antes lo resaltaba en todo el buffer, para que se pueda navegar por todas las ocurrencias del fichero, pero ralentizaba bastante. Ahora uso =smartscan=.
#+begin_src emacs-lisp
  (use-package auto-highlight-symbol
    :ensure t
    :config
      (setq ahs-idle-interval 3.0)
      (setq ahs-default-range 'ahs-range-display)
      (global-auto-highlight-symbol-mode))
#+end_src


** =transpose-frame= o =emacs-rotate.el=

   #+begin_src lisp
;; ACTUALMENTE SIN USAR
(use-package transpose-frame
  :ensure t
  :defer 1
  :bind
      (("<f5>" . transpose-frame))
)
   #+end_src

  
   #+begin_src emacs-lisp
(use-package rotate
  :ensure t
  :defer 1
  :bind 
  (("<f5>" .  rotate-layout )))

   #+end_src

   #+RESULTS:
   : rotate-layout
   
** =psw=

#+begin_src emacs-lisp
(use-package popup-switcher
  :ensure t
  :bind
  (("<M-f6>" . psw-switch-buffer)
   ("<C-o>" . psw-switch-projectile-files))
  )

#+end_src


** =ffap=
#+begin_src emacs-lisp
(use-package emacs
  :config
  (ffap-bindings))

#+end_src

** =company=
Utilizo =company= como mecanismo de autocomplección. Distingo entre modos de programación y =org-mode=.

#+begin_src emacs-lisp

  (use-package company
    :ensure t
    :config

    (setq company-tooltip-minimum-width 70)


    (defvar ags/company-backends-prog-mode
      '((company-capf :with
                      company-dabbrev-code
                      company-files
                      company-web-html
                      company-keywords
                      company-emoji
                      company-yasnippet)))


    (defvar ags/company-backends-org-mode
      '((company-capf :with
                      company-files
                      company-dabbrev
                      company-keywords
                      company-emoji
                      company-yasnippet)))

    (defvar ags/company-backends-tex-mode
      '((company-capf :with
                      company-files
                      company-dabbrev
                      company-keywords
                      company-emoji
                      company-yasnippet)))

    
    (defvar ags/company-backends ags/company-backends-org-mode)

    ;; set default `company-backends'
    (setq company-backends ags/company-backends)

    (defun ags/company-backends-org-mode-function ()
      (interactive)
      (set (make-local-variable 'company-backends) ags/company-backends-org-mode))

    (add-hook 'org-mode-hook #'ags/company-backends-org-mode-function)

    (defun ags/company-backends-prog-mode-function ()
      (interactive)
      (set (make-local-variable 'company-backends) ags/company-backends-prog-mode))

    (add-hook 'prog-mode-hook #'ags/company-backends-prog-mode-function)

    (defun ags/company-backends-tex-mode-function ()
      (interactive)
      (set (make-local-variable 'company-backends) ags/company-backends-tex-mode))

    (add-hook 'TeX-mode-hook #'ags/company-backends-tex-mode-function)
    
    (global-set-key (kbd "C-.") 'company-complete)
    (define-key company-active-map [escape] 'company-abort)


    (setq company-dabbrev-code-everywhere t)
    (setq company-dabbrev-minimum-length 2)
    (setq company-dabbrev-code-ignore-case nil)
    (setq company-dabbrev-everywhere t)
    (setq company-dabbrev-ignore-case 'keep-prefix)
    (setq company-dabbrev-downcase nil)
    (setq company-require-match nil)

    
    (global-company-mode)

    (define-key company-active-map (kbd "C-.") 'company-other-backend)

    (defun ags/company-quitar-candidatos-muy-largos (candidatos)
      (let ((ret
             (seq-filter (lambda (candidato) (length< candidato 50)) candidatos)))
        ret)

      ;; Intentarlo con advice arround (defun company-dabbrev--filter (prefix candidates)

      )
    
    ;;(add-to-list 'company-transformers #'ags/company-quitar-candidatos-muy-largos )
    ;;(add-to-list 'company-transformers #'delete-consecutive-dups )
    ;;(add-to-list 'company-transformers #'company-sort-by-occurrence )

    (setq company-idle-delay 0.2)
    (setq company-minimum-prefix-length 2)
    )


  (use-package company-auctex
    :ensure t
    :defer 1
    :config)


  (use-package company-c-headers
    :ensure t
    :defer 1
    :config)

  (use-package company-emoji
    :ensure t
    :defer 1
    :config)


  (use-package company-quickhelp
    :ensure t
    :defer 1
    :config
    (setq company-quickhelp-color-foreground "white")
    (setq company-quickhelp-color-background "darkgray")
    (company-quickhelp-mode 1) )

  (use-package company-web
    :ensure t
    :defer 1
    :config)

#+end_src


#+begin_src lisp
  (use-package company-fuzzy
    :ensure t
    :defer 1
    :hook (company-mode . company-fuzzy-mode)
    :config
    (setq company-fuzzy-sorting-backend 'flx
          company-fuzzy-prefix-on-top t
          company-fuzzy-show-annotation nil
          company-fuzzy-trigger-symbols '("." "->" "<" "\"" "'" "@")))

    (run-with-timer 2 nil (lambda ()
                         (message "Defino la función problemática company-fuzzy--insert-candidate")
 
                         (defun company-fuzzy--insert-candidate (candidate &rest otro)
                           "Insertion for CANDIDATE."
                           (when company-fuzzy-mode
                             ;; NOTE: Here we force to change `company-prefix' so the completion
                             ;; will do what we expected.
                             (let ((backend (company-fuzzy--get-backend-by-candidate candidate)))
                               (setq company-prefix (company-fuzzy--backend-prefix backend 'complete)))))
                         ))

#+end_src

* Edición


** /Backup/ de ficheros
Emacs guarda una copia de seguridad de los ficheros editados. Si no se configura, crea la copia en el mismo directorio.

Las copias de seguridad son interesantes aunque se utilice un control de versiones. Por ejemplo, se guardan versiones de ficheros del sistema y de los editados con Tramp.

Prefiero guardar todas las copias en un directorio, manteniendo varias versiones de cada fichero.

Tampoco me interesan los ficheros de /lock/.
#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . "~/.saves")))
(setq backup-by-copying t)
(setq delete-old-versions t
      kept-new-versions 6
      kept-old-versions 2
      version-control t)

(setq create-lockfiles nil)

(setq auto-save-file-name-transforms
      `((".*" "~/.saves" t)))

(setq delete-by-moving-to-trash t)
#+end_src

Grabar en el propio fichero
#+begin_src emacs-lisp
(setq auto-save-visited-interval 60)
(auto-save-visited-mode 1)
#+end_src

** Tabuladores /vs/ espacios
No utilizo tabuladores en las indentaciones. 
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
(setq tab-width 2)
#+end_src

** Comportamiento de la selección
Al comenzar a escribir con una selección, se borra lo seleccionado. 
#+begin_src emacs-lisp
(delete-selection-mode 1)
(transient-mark-mode 1)
#+end_src

Al copiar la  selección, mantener la selección 
#+begin_src emacs-lisp
(defadvice kill-ring-save (after keep-transient-mark-active ())
  "Override the deactivation of the mark."
  (setq deactivate-mark nil))
(ad-activate 'kill-ring-save)
#+end_src


** Historia del portapapeles
Una de las ventajas de Emacs es su /kill ring/, donde se guarda la historia del portapapeles. Con esta opción, añado a esta historia el portapapeles del sistema. Descubierto en [[https://writequit.org/org/settings.html#sec-1-33][https://writequit.org/org/settings.html#sec-1-33]]
#+begin_src emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+end_src

** Recarga de ficheros modificados
Encuentro más conveniente que los ficheros se recarguen si un programa externo los modifica, sin preguntas.

#+begin_src emacs-lisp
(use-package autorevert
  :ensure nil
  :config
  (global-auto-revert-mode 1)
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil))
#+end_src

** Comandos que se consideran /avanzados/
Emacs tiene algunos compandos considerados confusos deshabilitados. Hay opciones útiles que prefiero que estén activadas por defecto.
#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)
#+end_src

** Cerrar buferes sin preguntar
Cuando quiero cerrar un buffer, prefiero que no pregunte.
#+begin_src emacs-lisp
(defun kill-this-buffer-dont-ask ()
  (interactive)
  (kill-buffer (current-buffer)))
(global-set-key (kbd "C-x k") 'kill-this-buffer-dont-ask)
#+end_src


** Búsqueda incremental
Si empiezo una búsqueda con =C-s= o =C-r=, se empieza buscando la selección
#+begin_src emacs-lisp
;; https://www.reddit.com/r/emacs/comments/b7yjje/isearch_region_search/
(defun ags/isearch-region (&optional not-regexp no-recursive-edit)
  "If a region is active, make this the isearch default search pattern."
  (interactive "P\np")
  (when (use-region-p)
    (let ((search (buffer-substring-no-properties
                   (region-beginning)
                   (region-end))))
      ;;;(message "ags/ir: %s %d %d" search (region-beginning) (region-end))
      (setq deactivate-mark t)
      (isearch-yank-string search))))

(advice-add 'isearch-forward-regexp :after 'ags/isearch-region)
(advice-add 'isearch-forward :after 'ags/isearch-region)

(advice-add 'isearch-backward-regexp :after 'ags/isearch-region)
(advice-add 'isearch-backward :after 'ags/isearch-region)
#+end_src

Mostrar el número de ocurrencias
#+begin_src emacs-lisp
(setq isearch-lazy-count 't)
#+end_src

En una búsqueda incremental, utilizo =C-p= y =C-n= para ir a otras búsquedas anteriores
#+begin_src emacs-lisp
  ;; set arrow keys in isearch. left/right is backward/forward, up/down is history. press Return to exit
  (define-key isearch-mode-map (kbd "C-P") 'isearch-ring-retreat )
  (define-key isearch-mode-map (kbd "C-N") 'isearch-ring-advance )

  ;;(define-key isearch-mode-map (kbd "<left>") 'isearch-repeat-backward)
  ;;(define-key isearch-mode-map (kbd "<right>") 'isearch-repeat-forward)

  ;;(define-key minibuffer-local-isearch-map (kbd "<left>") 'isearch-reverse-exit-minibuffer)
  ;;(define-key minibuffer-local-isearch-map (kbd "<right>") 'isearch-forward-exit-minibuffer)
#+end_src

** Cancelar acción actual
A veces es fácil perderse entre comandos a medio introducir y ventanas popup. Me gusta que la tecla escape cancele cualquier acción. Con el siguiente código hago que se cancelen incluso más acciones que con =C-g=.
#+begin_src emacs-lisp
;;(define-key global-map [escape] 'keyboard-escape-quit)
;; (define-key key-translation-map (kbd "ESC") (kbd "C-g")) // PROBLEMAS CON EL TERMINAL
(defun ags/super-escape()
  (interactive)
  (keyboard-escape-quit)
  (minibuffer-keyboard-quit)
  (keyboard-quit)
  (company-abort)
  (abort-recursive-edit)
  (setq quit-flag t))
(define-key global-map [escape] 'ags/super-escape)
(define-key minibuffer-local-map [escape] 'ags/super-escape)
(define-key company-active-map [escape] 'company-abort)
#+end_src


** Atajos de teclado varios
Algunas teclas definidas a nivel global son sobreescritas por algunos modos (por ejemplo, prefiero que =C-Z= sea "deshacer"). Para poder definir teclas con prioridad sobre los demás modos defino un modo con mis atajos.
#+begin_src emacs-lisp

  (defun ags/toggle-truncate-lines()
    (interactive)
    (visual-line-mode 'toggle)
    (adaptive-wrap-prefix-mode 1))

  ;; MIS TECLAS
  (defvar mis-teclas-minor-mode-map
    (let ((map (make-sparse-keymap)))

      (define-key map (kbd "C-z") 'undo )
      (define-key map (kbd "C-x C-d") 'dired)
      (define-key map (kbd "C-x d") 'dired-other-frame)
      (define-key map (kbd "C-x C-b") 'ibuffer)
      (define-key map (kbd "C-x b") 'ibuffer)
      (define-key map (kbd "C-<f5>") 'ags/reveal-y-pdf)
      (define-key map (kbd "M-S-<up>") 'enlarge-window)
      (define-key map (kbd "M-S-<down>") 'shrink-window)
      (define-key map (kbd "M-S-<left>") 'shrink-window-horizontally)
      (define-key map (kbd "M-S-<right>") 'enlarge-window-horizontally)
      (define-key map (kbd "C-x M-x") 'execute-extended-command)
      (define-key map (kbd "C-S-l") 'ags/toggle-truncate-lines)
      map)
    "mis-teclas-minor-mode keymap")
                        

  (define-minor-mode mis-teclas-minor-mode
    "A minor mode so that my key settings override annoying major modes."
    :init-value t
    :lighter "mis-teclas")

  (mis-teclas-minor-mode 1)

#+end_src




** Macros de teclado
Necesario si una macro resulta interesante, para grabarla como una función
#+begin_src emacs-lisp
(use-package elmacro
  :ensure t
  :defer 1
  :config
  (setq elmacro-show-last-commands-default 100)
  :init
  (elmacro-mode))
#+end_src

#+RESULTS:
: t

* Navegación
** =toggle-term=

#+begin_src emacs-lisp
(use-package toggle-term
  :bind (;;("M-o f" . toggle-term-find)
         ("M-o t" . toggle-term-term)
         ;;("M-o s" . toggle-term-shell)
         ;;("M-o e" . toggle-term-eshell)
         ;;("M-o i" . toggle-term-ielm)
         ;;("M-o o" . toggle-term-toggle)
         )
  :config
    (setq toggle-term-size 25)
    (setq toggle-term-switch-upon-toggle t))
#+end_src

#+RESULTS:
: toggle-term-term

** =tree-sitter=
Puede que sea una buena idea, pero de momento no le saco partido.

#+begin_src emacs-lisp
(setq treesit-language-source-alist
   '((bash "https://github.com/tree-sitter/tree-sitter-bash")
     (cmake "https://github.com/uyha/tree-sitter-cmake")
     (css "https://github.com/tree-sitter/tree-sitter-css")
     (elisp "https://github.com/Wilfred/tree-sitter-elisp")
     (go "https://github.com/tree-sitter/tree-sitter-go")
     (html "https://github.com/tree-sitter/tree-sitter-html")
     (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
     (json "https://github.com/tree-sitter/tree-sitter-json")
     (make "https://github.com/alemuller/tree-sitter-make")
     (markdown "https://github.com/ikatyang/tree-sitter-markdown")
     (python "https://github.com/tree-sitter/tree-sitter-python")
     (toml "https://github.com/tree-sitter/tree-sitter-toml")
     (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
     (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
     (yaml "https://github.com/ikatyang/tree-sitter-yaml")))

(add-to-list 'treesit-language-source-alist '(kotlin . ("https://github.com/fwcd/tree-sitter-kotlin")))

(use-package treesit-auto
  :demand t
  :ensure t
  :config
  (global-treesit-auto-mode))
#+end_src

#+RESULTS:
: t

** =dev-docs=


#+begin_src emacs-lisp
(use-package devdocs
  :ensure t
  :defer 1)


#+end_src

** =file-info=
#+begin_src emacs-lisp
(use-package file-info
  :ensure t
  :bind (("C-c d" . 'file-info-show))
  :config
  (setq hydra-hint-display-type 'posframe)
  (setq hydra-posframe-show-params `(:poshandler posframe-poshandler-frame-center
                                               :internal-border-width 2
                                               :internal-border-color "#61AFEF"
                                               :left-fringe 16
                                               :right-fringe 16)))
#+end_src

** =tramp=
=tramp= intenta optimizar las conexiones, enviando en línea los ficheros pequeños. Esto me da problemas en algunos sistemas, así que indico que los ficheros se copien a partir de 1 byte de tamaño:
#+begin_src emacs-lisp
(use-package tramp
  :config
  (setq tramp-inline-compress-start-size 1000)
  (setq tramp-copy-size-limit 10000)
  (setq vc-handled-backends '(Git))
  (setq tramp-auto-save-directory "/tmp")
  (setq tramp-allow-unsafe-temporary-files t)
  (setq tramp-verbose 1)
  (setq tramp-default-method "scp")
  (setq tramp-use-ssh-controlmaster-options nil)
  (setq projectile--mode-line "Projectile")
  (setq tramp-verbose 1)
  (setq tramp-connection-timeout 10))

(defun ags/tramp-wait-for-regexp (original-function &rest args)
  ;; If TIMEOUT is nil, then set it to 5 seconds
  ;; Original args are: proc timeout regexp
  (let ( (proc (nth 0 args))
         (timeout (or (nth 1 args) 10 ) )
         (regexp) (nth 2 args) )
    (message "AGS: timeout was %d, now %d" (nth 1 args) timeout)
    (funcall original-function proc timeout regexp)))


;;(advice-add #'tramp-wait-for-regexp :around #'ags/tramp-wait-for-regexp)
;;(advice-remove #'tramp-wait-for-regexp #'ags/tramp-wait-for-regexp)

#+end_src

Desactivo otros sistemas de control de versiones que no sean =git=. Dejo preparado un hook para cuando un fichero sea remoto.
https://www.reddit.com/r/emacs/comments/y92y4b/tramp_users_slowness_got_you_down_check/
#+begin_src emacs-lisp
(setq vc-handled-backends '(Git))
(defun ags/vc-off-if-remote ()
  (when (file-remote-p (buffer-file-name))
    (setq-local vc-handled-backends '())
    (setq-local vc-dir-backend nil)))
(add-hook 'find-file-hook 'ags/vc-off-if-remote)
#+end_src

En ocasiones, =tramp= no consigue conectar con un usuario que tiene =zsh= como shell. Para ello, hay que añadir lo siguiente al fichero =.zshrc= remoto:
#+begin_src sh
# EN .zshrc PARA QUE FUNCIONE tramp
if [[ "$TERM" == "dumb" ]]
then
  unsetopt zle
  unsetopt prompt_cr
  unsetopt prompt_subst
  unfunction precmd
  unfunction preexec
  PS1='$ '
fi
#+end_src

** Modo de ficheros recientes
#+begin_src emacs-lisp
(recentf-mode 1)
(setq recentf-max-saved-items 2000)
(save-place-mode 1)
(savehist-mode 1)
(setq savehist-autosave-interval 30)
#+end_src

** Ratón en =xterm=
El ratón también puede utilizarse en un =xterm=
#+begin_src emacs-lisp
(xterm-mouse-mode)
#+end_src

** Guardar el fichero de bookmarks cada vez que se modifiquen
#+begin_src emacs-lisp
(setq bookmark-save-flag 1)
#+end_src

** Correo electrónico
Para enviar email utilizo =sendmail= (lo suelo tener configurado con un /smarthost/)
#+begin_src emacs-lisp
(setq send-mail-function (quote sendmail-send-it))
#+end_src

* Visualización

** =spacious-padding=

#+begin_src emacs-lisp
(use-package spacious-padding
  :ensure t
  :defer 1
  :config
  (spacious-padding-mode 1))

#+end_src

** =hl-todo=


#+begin_src emacs-lisp
(use-package hl-todo
  :ensure t
  :defer 1
  :config
  (hl-todo-mode 1))

#+end_src

** =hl-todo-flycheck=

#+begin_src lisp
(use-package hl-todo-flycheck
  :ensure t
  :defer 5
  :straight (:host github :repo "alvarogonzalezsotillo/hl-todo-flycheck")
  :config
  (hl-todo-flycheck-enable)
)
#+end_src


** =vimish-fold=
No me acaba de gustar, vuelvo a origami
#+begin_src lisp
(use-package vimish-fold
  :ensure t
  :defer 1
  ;; :bind
  ;; (("<C-return>" . vimish-fold-toggle)
  ;;  ("<C-S-return>" . vimish-fold-from-marks)
  ;;  ("<M-return>" . vimish-fold ))
  :config
   (vimish-fold-global-mode 1))
   
#+end_src



** =origami=

Desactivados los bindings, voy a usar vimish-fold

   #+begin_src emacs-lisp

(use-package origami
  :defer 1
  :ensure t
  :config
  (setq origami-show-fold-header nil)
  (setq origami-fold-replacement "⤵⤵⤵")
  (set-face-attribute 'origami-fold-header-face nil :box nil :background 'unspecified :height 0.5)
  (set-face-attribute 'origami-fold-replacement-face nil :box '(:line-width 1 :color unspecified) :background 'unspecified :height  0.5)

  :bind
  (("<C-return>" . origami-recursively-toggle-node))
  (("<C-S-return>" . origami-reset))
  (("<M-return>" . origami-close-all-nodes))

  )

   #+end_src

** =
#+begin_src emacs-lisp
(use-package outline-indent
  :ensure t
  :defer 1
  :custom
  (outline-indent-ellipsis " ▼ "))
#+end_src 

#+RESULTS:
: [nil 0 1 0 nil require (outline-indent nil t) idle 0 nil]

** =sideline=

#+begin_src emacs-lisp

(use-package sideline-flycheck
  :defer 1
  :ensure t
  :hook (flycheck-mode . sideline-flycheck-setup))

(use-package sideline-blame
  :defer 1
  :ensure t )

(use-package sideline
  :defer 1
  :ensure t
  :init

  :hook (flycheck-mode . sideline-mode)

  :config
  
  (setq sideline-backends-right '((sideline-flycheck . up)))



  (setq sideline-backends-skip-current-line t  ; don't display on current line
        sideline-order-left 'down              ; or 'up
        sideline-order-right 'up               ; or 'down
        sideline-format-left "%s   "           ; format for left aligment
        sideline-format-right "   %s"          ; format for right aligment
        sideline-priority 100                  ; overlays' priority
        sideline-display-backend-name nil))      ; display the backend name
#+end_src

#+RESULTS:
| sideline-mode | sideline-flycheck-setup | rustic-flycheck-setup | flycheck-mode-set-explicitly |


** Pantalla inicial (/dashboard/)
#+begin_src emacs-lisp
(use-package dashboard
  :ensure t
  :defer 1
  :config
  (dashboard-setup-startup-hook)
  (setq dashboard-startup-banner nil)  
  (setq dashboard-items '((recents  . 0)
                          (bookmarks . 0)
                          (projects . 10)))
  (setq dashboard-set-heading-icons t)
  (setq dashboard-set-file-icons t)  
  (setq initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))
  )
#+end_src

#+RESULTS:
: t




** /wrap/ adaptativo

#+begin_src emacs-lisp
(use-package adaptive-wrap
  :ensure t
  :defer 1
  )
#+end_src

#+RESULTS:
: [nil 0 1 0 nil require (adaptive-wrap nil t) idle 0 nil]

** Código fuente

#+begin_src emacs-lisp
(defun ags/bonito-para-codigo()
  (interactive)
  (blamer-mode -1)
  (toggle-truncate-lines 1)
  ;;(indent-guide-mode 1)
  (toggle-word-wrap 1)
  (if (>= emacs-major-version 26)
      (display-line-numbers-mode 1))
  (auto-highlight-symbol-mode 1)
  (electric-pair-local-mode 1)
  (indent-bars-mode 1)
  (origami-mode 1))

  (add-hook 'prog-mode-hook 'ags/bonito-para-codigo)
#+end_src

#+RESULTS:
| yas-minor-mode | ags/bonito-para-codigo | ags/company-backends-prog-mode-function |

** LaTeX
#+begin_src emacs-lisp
(defun ags/bonito-para-latex()
  (interactive)
  (toggle-truncate-lines -1)
  (setq magic-latex-enable-suscript nil)
  (company-auctex-init)
  (message "LATEX")
  (magic-latex-buffer 1))

(add-hook 'LaTeX-mode-hook 'ags/bonito-para-latex)
(add-hook 'tex-mode-hook 'ags/bonito-para-latex)
#+end_src



** /Fringes/
Antes ocultaba los fringes, ahora los dejo para =diff-hl=
#+begin_src emacs-lisp
(if (display-graphic-p)
  (fringe-mode '(nil . nil)))
#+end_src


** /Modeline/
Mi línea de estado (modeline)
#+begin_src emacs-lisp
(setq ags/mode-line-format
              (list
               " "
               '(:eval (propertize "[☰]" 'local-map (make-mode-line-mouse-map 'mouse-1 'menu-bar-open)))
               " "
               mode-line-modified
               " %[" mode-line-buffer-identification " %] "
               " | " '(vc-mode vc-mode)
               " | %m %n "
               " | %IB %Z"
               " | %l:%c %p"
               ;;" | " '(:eval (format "Point:%d" (point)))
               ;;" | " '(:eval (breadcrumb-project-crumbs)) " / " '(:eval (breadcrumb-imenu-crumbs))
               mode-line-end-spaces
               ) )

(setq-default mode-line-format ags/mode-line-format)

(use-package mode-icons
  :ensure t
  :defer 1
  :config
  (mode-icons-mode))
#+end_src

#+RESULTS:
: t

** Paquete =doc-view=
Para visualizar documentos desde Emacs, aumento su resolución y anchura.
#+begin_src emacs-lisp
(use-package doc-view
  :config
  (setq doc-view-continuous t)
  (setq doc-view-image-width 1600)
  (setq doc-view-resolution 400))
#+end_src


** Cursor
Cursor como barra vertical
#+begin_src emacs-lisp
(set-default 'cursor-type 'bar)
(set-default 'cursor-in-non-selected-windows 'hollow)
(defun ags/change-cursor-when-overwrite ()
  (setq cursor-type (if overwrite-mode 'box 'bar)))
(add-hook 'overwrite-mode-hook #'ags/change-cursor-when-overwrite)
(blink-cursor-mode 1)
(setq blink-cursor-blinks 0)
#+end_src

** Líneas vacías al final, como =vim=
Los ficheros deben tener una línea nueva al final. Además, indicar el fin de fichero como en =vim=.
#+begin_src emacs-lisp
(setq indicate-empty-lines t require-final-newline t)
#+end_src

** /scroll/
#+begin_src emacs-lisp
  (setq scroll-margin 0
       scroll-step 1
       scroll-conservatively 10000
       scroll-preserve-screen-position 1)

  (setq jit-lock-defer-time 0)
  (setq fast-but-imprecise-scrolling t)


#+end_src

** Ratón
Scroll con teclas de avance de página hasta el extremo del fichero.
Sin esta opción, /Emacs/ no avanza hasta la primera línea si al dar a =RePag= no quedan páginas por retroceder.
   
[[https://stackoverflow.com/questions/445873/how-can-i-make-emacs-mouse-scrolling-slower-and-smoother]]
   #+begin_src emacs-lisp
     (setq scroll-error-top-bottom t)
     (setq mouse-wheel-progressive-speed nil)
     (setq mouse-wheel-scroll-amount '(1 ((shift) . 2) ((control) . nil))) 
   #+end_src

Scroll lateral con el touchpad   
#+begin_src emacs-lisp
(global-set-key (kbd "<mouse-6>") (lambda() (interactive) (scroll-right 10)))
(global-set-key (kbd "<mouse-7>") (lambda() (interactive) (scroll-left 10)))
(put 'scroll-left 'disabled nil)
(put 'scroll-right 'disabled nil)
#+end_src


** Números de línea

#+begin_src emacs-lisp
(setq display-line-numbers-width 3)
#+end_src

** Líneas muy largas
Avoid performance issues in files with very long lines.
#+begin_src emacs-lisp
(unless (version<= emacs-version "27")
  (global-so-long-mode 1))
#+end_src

** Resaltar términos buscados
=isearch= resalta las coincidencias con la búsqueda, pero se quitan al acabar de buscar. Con esto, las coincidencias quedan resaltadas hasta la siguiente búsqueda o hasta ejecutar =lazy-highlight-cleanup=
#+begin_src emacs-lisp
(setq lazy-highlight-cleanup nil)
(setq isearch-lazy-highlight 'all-windows)
(setq lazy-highlight-max-at-a-time nil)
(setq lazy-highlight-initial-delay 0)
#+end_src

** Cambiar el tamaño de fuente de todo /emacs/ (no solo el buffer actual)
#+begin_src emacs-lisp
  (use-package default-text-scale
    :ensure t
    :config
    (setq frame-resize-pixelwise t)
    (default-text-scale-mode 1)
    )
#+end_src


** Respuestas de confirmación más cortas
#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Desactivar la campana (/bell/)
Tanto la señal auditiva como la visual
#+begin_src emacs-lisp
(setq visible-bell 1)
(setq ring-bell-function 'ignore)
#+end_src

** Barras de desplazamiento, de herramientas y menú
La barra de menú y la de herramientas es de lo primero que se quita al personalizar /emacs/, lo mismo que esa pantalla de inicio.
#+begin_src emacs-lisp
(setq inhibit-startup-message t)
(ignore-errors (menu-bar-mode -1))
(ignore-errors (tool-bar-mode -1))
(ignore-errors (scroll-bar-mode 1))
#+end_src

** Ancho de la página de =man=
#+begin_src emacs-lisp
(setenv "MANWIDTH" "80")
#+end_src

** Mostrar paréntesis asociados
#+begin_src emacs-lisp
(show-paren-mode)
#+end_src

** Servidor emacs
Arranco el servidor para utilizar /emacsclient/
#+begin_src emacs-lisp
  (use-package server
    :config
    (setenv "EDITOR" "emacsclient -c")
    (unless (server-running-p)
      (server-start))
    )
#+end_src

* Temas
Tengo dos temas, claro y oscuro. 

Hay que marcar los temas como seguros. Para eso se deben registrar sus huellas en =custom-safe-themes= (lo he copiado del fichero =custom-file.el=).


#+begin_src emacs-lisp
(use-package emacs
  :config
  (setq  custom-safe-themes  (quote
                              (
                               "b53db91fd0153783f094a2d5480119824b008f158e07d6b84d22f8e6b063d6e2"
                               "d916b686ba9f23a46ee9620c967f6039ca4ea0e682c1b9219450acee80e10e40" 
                               default)))

  (defvar my-dark-theme 'my-tangotango)
  (defvar my-light-theme 'intellij)


  (defun ags/tema-claro()
    (interactive)
    (disable-theme my-dark-theme)
    (load-theme my-light-theme t))

  (defun ags/tema-oscuro ()
    (interactive)
    (disable-theme my-light-theme)
    (load-theme my-dark-theme t))

  (run-with-idle-timer 2 nil #'ags/tema-oscuro)
  )
#+end_src

* OrgMode

Con estos cambios, se tienen en cuenta los formatos de orgmode en =electric-pair-mode=

#+begin_src emacs-lisp
  (use-package org
    :config
    (modify-syntax-entry ?~ "(~" org-mode-syntax-table)
    (modify-syntax-entry ?= "(=" org-mode-syntax-table)
    (modify-syntax-entry ?_ "(_" org-mode-syntax-table)
    (modify-syntax-entry ?* "(*" org-mode-syntax-table)
    (modify-syntax-entry ?/ "(/" org-mode-syntax-table)
    )
#+end_src

Mejores tamaños de encabezados

#+begin_src emacs-lisp
  (use-package org
    :config
    (set-face-attribute 'org-level-1 nil :height 3.0)
    (set-face-attribute 'org-level-2 nil :height 2.0)
    (set-face-attribute 'org-level-3 nil :height 1.5)
    )
#+end_src


Imágenes tras evaluar
#+begin_src emacs-lisp
(use-package org
  :config
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images))
#+end_src


#+begin_src emacs-lisp
  (use-package org
    :config

    (use-package org-bullets
      :ensure t
      :defer t
      :config
      (org-bullets-mode 1))


    (defun ags/org-export-deterministic-reference (references)
      (let ((new (length references)))
        (while (rassq new references) (setq new (+ new 1))) 
        new))
    (advice-add #'org-export-new-reference :override #'ags/org-export-deterministic-reference)


    (setq org-ellipsis "⤵⤵⤵")
    (set-face-attribute 'org-ellipsis nil :box '(:line-width 1 :color unspecified) :background 'unspecified)
    (setq org-list-allow-alphabetical t)
    (org-element-update-syntax)
    
    ;;(setq org-hide-emphasis-markers t)

    ;;Trying to fix indentation behaviour within code blocks.
    (setq org-edit-src-content-indentation 0)
    (setq org-src-fontify-natively t)
    (setq org-src-tab-acts-natively t)
    (setq org-src-preserve-indentation t)

    ;; https://stackoverflow.com/questions/40110927/how-to-export-a-reference-to-a-begin-src-block-to-latex/40689439#40689439
    (setq org-latex-prefer-user-labels t)

    (setq org-image-actual-width '(400))

    ;; Desde la versión 9 de orgmode, los templates rápidos no están activados por defecto si no se carga org-tempo
    (ignore-errors
      (require 'org-tempo)
      ;; si no existe org-tempo no se llega aquí, lo cual está bien porque lo siguiente solo hay que hacerlo para org-tempo
      (setq org-structure-template-alist 
            '(("n" . "notes")
              ("a" . "export ascii")
              ("c" . "center")
              ("C" . "comment")
              ("e" . "example")
              ("E" . "export")
              ("h" . "export html")
              ("l" . "export latex")
              ("q" . "quote")
              ("s" . "src")
              ("v" . "verse")))
      )

      (defun ags/bonito-para-org()
        (interactive)
        (toggle-word-wrap 1)
        ;;(indent-guide-mode 0)
        (if (>= emacs-major-version 26)
            (display-line-numbers-mode 0))
        (org-display-inline-images)
        (auto-highlight-symbol-mode 1)
        (org-bullets-mode 1)
        (blamer-mode -1)
        (electric-pair-local-mode 1))

      (add-hook 'org-mode-hook 'ags/bonito-para-org)
    )
#+end_src




** Lenguajes =org-babel=
Habilito varios lenguajes que pueden ejecutarse directamente desde los bloques de =orgmode=.
#+begin_src emacs-lisp
(use-package ob-typescript
  :ensure t
  :defer 1)

(use-package ob-restclient
  :ensure t
  :defer 1)

(use-package d2-mode
  :ensure t
  ;; DEBE SER CARGADO ANTES QUE ob-d2, para ob-d2 sobreescriba la función de babel de d2-mode, para que funcionen los flags
  )

(use-package ob-d2
  :ensure t
  :defer 1
  ;; DEBE SER CARGADO TRAS d2-mode
  )

(use-package emacs
  :config
  (if
      (file-exists-p "/usr/share/plantuml/plantuml.jar")
      (setq org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
    (setq org-plantuml-jar-path (expand-file-name "~/.emacs.d/bin/plantuml.1.2018.11.jar")))

  (setq plantuml-jar-path org-plantuml-jar-path)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '(
     (C . t )
     (dot . t)
     (plantuml . t)
     (maxima . t)
     (typescript . t)
     (js . t)
     (restclient . t )
     (d2 . t)
     (shell . t)))

  (add-to-list 'org-babel-tangle-lang-exts '("js" . "js"))
)
#+end_src

#+RESULTS:
: t


 Además, no pido confirmación para varios lenguajes                                                                                                           
 #+begin_src emacs-lisp
 (defun ags/org-confirm-babel-evaluate (lang body)
   (not (member lang '("dot" "emacs-lisp" "shell" "plantuml" "maxima" "d2"))))
 (setq org-confirm-babel-evaluate 'ags/org-confirm-babel-evaluate)
#+end_src



** Listados /Latex/
Utilizo el paquete =listings= de /Latex/ en vez de bloques /verbatim/.
#+begin_src emacs-lisp
(setq org-latex-listings t)
#+end_src

** Selección con mayúsculas 
#+begin_src emacs-lisp
(setq org-support-shift-select 'always)
#+end_src




* Latex 

#+begin_src emacs-lisp

(use-package magic-latex-buffer
  :ensure t
  :defer 1)

(use-package latex
  :ensure auctex
  :config
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq TeX-save-query nil)
  (setq TeX-PDF-mode t)

  ;; Para que funcione correctamente el resaltado de sintaxis, hay que informar a Auctex de los entornos /verbatim/ utilizados:

  (setq LaTeX-verbatim-environments
        '("verbatim" "verbatim*" "listadotxt" "PantallazoTexto" "listadosql" "listadoshell" "listadojava"))


  (add-to-list 'auto-mode-alist '("\\.tex\\'" . latex-mode))


  ;; Para imenu, defino una macro de Latex que no hace nada, pero que detecto en imenu.
  (add-to-list 'TeX-outline-extra '("imenu" 2))
  (add-to-list 'TeX-outline-extra '("imenuone" 1))
  (add-to-list 'TeX-outline-extra '("imenutwo" 2))
  (add-to-list 'TeX-outline-extra '("imenuthree" 3))
  (add-to-list 'TeX-outline-extra '("imenufour" 4))

  ;; En Ubuntu, Evince puede sincronizarse con Emacs para saber a qué parte de código corresponde una parte del PDF y viceversa
  (setq TeX-view-program-selection '((output-pdf "Okular")))
  (setq TeX-source-correlate-mode t)
  (add-hook 'latex-mode-hook 'TeX-source-correlate-mode)

  ;; Para que funcione con Okular, hay que sar tools -> Browse

  (setq TeX-source-correlate-start-server t)



  ;; Modifico el comando Latex para incluir =-shell-escape=, de forma que Latex pueda arrancar programas de ayuda (por ejemplo, *Inkscape* para convertir SVG a PDF)
  (setq LaTeX-command-style
        (quote (("" "%(PDF)%(latex) %(file-line-error) -shell-escape %(extraopts) %S%(PDFout)"))))


  ;; Se pueden previsualizar los entornos =tikzpicture= y =tabular= directamente en el buffer de Emacs ([[https://www.gnu.org/software/auctex/manual/preview-latex.html][https://www.gnu.org/software/auctex/manual/preview-latex.html]])
  (eval-after-load "preview"
    '(add-to-list 'preview-default-preamble "\\PreviewEnvironment{tikzpicture}" t) )
  (eval-after-load "preview"
    '(add-to-list 'preview-default-preamble "\\PreviewEnvironment{tabular}" t) )
  (eval-after-load "preview"
    '(add-to-list 'preview-default-preamble "\\PreviewEnvironment{homeworkProblem}" t) )

  ;; Añadir XeLatex
  (eval-after-load "tex"
    '(add-to-list 'TeX-command-list
     		  '("XeLaTeX" "xelatex -interaction=nonstopmode %s"
		    TeX-run-command t t :help "Run xelatex") t))

  ;; En =Termux= se necesita especificar la camino a la /shell/ para ejecutar comandos de /Latex/
  (if
      (file-exists-p "/data/data/com.termux/files/usr/bin/sh")
      (setq TeX-shell  "/data/data/com.termux/files/usr/bin/sh"))
  )
#+END_SRC

* Javascript

Añado a la lista de extensiones la de los módulos.
   #+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.mjs\\'" . js2-mode))
   #+end_src

* kotlin

#+begin_src emacs-lisp
(use-package kotlin-mode
  :ensure t
  :defer 1
  )
#+end_src

   
* Rust

#+begin_src emacs-lisp
(use-package rustic
  :ensure t
  :defer 1
  :config
  
  ;; uncomment for less flashiness
  ;; (setq lsp-eldoc-hook nil)
  ;; (setq lsp-enable-symbol-highlighting nil)
  ;; (setq lsp-signature-auto-activate nil)

  ;; comment to disable rustfmt on save
  (setq rustic-format-on-save t)
  
  )

#+end_src


#+begin_src emacs-lisp
(use-package lsp-mode
  :ensure t
  :defer 1
  :commands lsp
  :custom
  ;; what to use when checking on-save. "check" is default, I prefer clippy
  (lsp-rust-analyzer-cargo-watch-command "clippy")
  (lsp-eldoc-render-all nil)
  (lsp-idle-delay 0.6)
  ;; enable / disable the hints as you prefer:
  (lsp-rust-analyzer-server-display-inlay-hints t)
  (lsp-rust-analyzer-display-lifetime-elision-hints-enable "skip_trivial")
  (lsp-rust-analyzer-display-chaining-hints t)
  (lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names nil)
  (lsp-rust-analyzer-display-closure-return-type-hints t)
  (lsp-rust-analyzer-display-parameter-hints t)
  (lsp-rust-analyzer-display-reborrow-hints t)
  :config
  (add-hook 'lsp-mode-hook 'lsp-ui-mode)
  (yas-reload-all)
  )
  

(use-package lsp-ui
  :ensure t
  :defer 1
  :commands lsp-ui-mode
  :custom
  (lsp-ui-peek-always-show t)
  (lsp-ui-sideline-show-hover t)
  (lsp-ui-doc-enable nil))

(use-package yasnippet
  :ensure t
  :defer 1
  :config
  (yas-global-mode))

(use-package yasnippet-snippets
  :ensure t
  :defer 1)


#+end_src





* XQuery
https://github.com/paddymcall/xquery-tool.el/blob/master/xquery-tool.el
#+begin_src emacs-lisp
(use-package xquery-tool
  :ensure t
  :straight (:host github :repo "paddymcall/xquery-tool.el")
  :defer 1
  :config
)
#+end_src



* Mastodon
#+begin_src lisp
(use-package mastodon
  :ensure t
  :config
  (setq mastodon-instance-url "https://fosstodon.org"
        mastodon-active-user "@alvarogonzalezsotillo"))
#+end_src


* Zona de pruebas


#+begin_src emacs-lisp
(use-package ellama
  :defer 1
  :ensure t
  :config
  ;;fx-3EyjaAPRl4pK3cgyIDptG3OyoxSWPInCMh8dv4SN4Utws3h9
  )


#+end_src

#+RESULTS:
: [nil 0 1 0 nil require (ellama nil t) idle 0 nil]


#+begin_src lisp
(use-package selection-highlight-mode
  :straight (selection-highlight-mode :type git
                                      :host github
                                      :repo "balloneij/selection-highlight-mode")
  :config (selection-highlight-mode))
#+end_src



#+begin_src emacs-lisp

(use-package impatient-mode
  :defer 1
  :ensure t
  :config 

  (defun ags/org-buffer-to-html-string (buffer)
    "Convierte el contenido del buffer Org actual a una cadena HTML."
    (require 'ox-html) ;; Asegúrate de que el paquete ox-html esté cargado

    ;; Configura las opciones de exportación según tus preferencias
    (with-current-buffer buffer
      (princ (org-export-string-as (buffer-string) 're-reveal t))
      (princ "hola")))
    


  (add-to-list 'imp-default-user-filters '(org-mode . ags/org-buffer-to-html-string))
  
  )
#+end_src

* Opciones Latex para el PDF :noexport:
# COLORES
#+latex_header: \usepackage[usenames,dvipsnames]{color} % Required for custom colors

# LISTADOS LATEX
#+latex_header: \renewcommand{\ttdefault}{pcr} % MONOESPACIO CON NEGRITA
#+latex_header: \usepackage{listings}
#+latex_header: \usepackage{listingsutf8}
#+latex_header: \usepackage{indentfirst}
#+latex_header: \lstset{frame=single,inputencoding=utf8,basicstyle=\scriptsize\ttfamily,showstringspaces=false,numbers=none}
#+latex_header: \definecolor{MyDarkGreen}{rgb}{0.0,0.4,0.0} % This is the color used for comments
#+latex_header: \lstset{ breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}, keywordstyle=\bfseries, keywordstyle=[1]\color{Blue}\bfseries,  keywordstyle=[2]\color{Purple}\bfseries,  keywordstyle=[3]\color{Blue}\underbar,   identifierstyle=,   commentstyle=\color{MyDarkGreen},   stringstyle=\color{Purple},   showstringspaces=false,   tabsize=2,   morecomment=[l][\color{Blue}]{...} }
#+latex_header: \lstset{literate=  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1   {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1   {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1   {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1   {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1   {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1   {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1   {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1   {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1   {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1   {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1   {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1   {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1 } 

# OPCIONES DE PÁGINA DE LATEX
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS:
#+LATEX_HEADER: \usepackage[margin=2.5cm,includeheadfoot,includehead,includefoot]{geometry} 
#+LATEX_HEADER: \hypersetup{colorlinks,linkcolor=black}

# CABECERA Y PIE LATEX
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \pagestyle{fancyplain}
#+LATEX_HEADER: \chead{}
#+LATEX_HEADER: \lhead{}
#+LATEX_HEADER: \rhead{}
#+LATEX_HEADER: \cfoot{}
#+LATEX_HEADER: \lfoot{alvarogonzalezsotillo@gmail.com}
#+LATEX_HEADER: \rfoot{\thepage}
